{
  "version": 3,
  "sources": ["../../ol/source/BingMaps.js", "../../ol/source/CartoDB.js", "../../ol/source/Cluster.js", "../../ol/source/DataTile.js", "../../ol/source/GeoTIFF.js", "../../ol/source/Google.js", "../../ol/source/Zoomify.js", "../../ol/format/IIIFInfo.js", "../../ol/source/IIIF.js", "../../ol/source/arcgisRest.js", "../../ol/source/ImageArcGISRest.js", "../../ol/source/ImageCanvas.js", "../../ol/source/mapguide.js", "../../ol/source/ImageMapGuide.js", "../../ol/source/static.js", "../../ol/source/ImageStatic.js", "../../ol/source/ImageTile.js", "../../ol/source/ImageWMS.js", "../../ol/net.js", "../../ol/source/ogcTileUtil.js", "../../ol/source/OGCMapTile.js", "../../ol/source/VectorTile.js", "../../ol/source/OGCVectorTile.js", "../../ol/source/Raster.js", "../../ol/source/StadiaMaps.js", "../../ol/source/TileArcGISRest.js", "../../ol/source/TileDebug.js", "../../ol/source/TileJSON.js", "../../ol/source/UTFGrid.js", "../../ol/source/WMTS.js", "../../ol/source.js"],
  "sourcesContent": ["/**\n * @module ol/source/BingMaps\n */\n\nimport TileImage from './TileImage.js';\nimport {applyTransform, intersects} from '../extent.js';\nimport {createFromTileUrlFunctions} from '../tileurlfunction.js';\nimport {createOrUpdate} from '../tilecoord.js';\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\nimport {get as getProjection, getTransformFromProjections} from '../proj.js';\n\n/**\n * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coord.\n * @return {string} Quad key.\n */\nexport function quadKey(tileCoord) {\n  const z = tileCoord[0];\n  const digits = new Array(z);\n  let mask = 1 << (z - 1);\n  let i, charCode;\n  for (i = 0; i < z; ++i) {\n    // 48 is charCode for 0 - '0'.charCodeAt(0)\n    charCode = 48;\n    if (tileCoord[1] & mask) {\n      charCode += 1;\n    }\n    if (tileCoord[2] & mask) {\n      charCode += 2;\n    }\n    digits[i] = String.fromCharCode(charCode);\n    mask >>= 1;\n  }\n  return digits.join('');\n}\n\n/**\n * The attribution containing a link to the Microsoft® Bing™ Maps Platform APIs’\n * Terms Of Use.\n * @const\n * @type {string}\n */\nconst TOS_ATTRIBUTION =\n  '<a class=\"ol-attribution-bing-tos\" ' +\n  'href=\"https://www.microsoft.com/maps/product/terms.html\" target=\"_blank\">' +\n  'Terms of Use</a>';\n\n/**\n * @typedef {Object} Options\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\n * @property {boolean} [hidpi=false] If `true` hidpi tiles will be requested.\n * @property {string} [culture='en-us'] Culture code.\n * @property {string} key Bing Maps API key. Get yours at https://www.bingmapsportal.com/.\n * @property {string} imagerySet Type of imagery.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {number} [maxZoom=21] Max zoom. Default is what's advertized by the BingMaps service.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n * @property {boolean} [placeholderTiles] Whether to show BingMaps placeholder tiles when zoomed past the maximum level provided in an area. When `false`, requests beyond\n * the maximum zoom level will return no tile. When `true`, the placeholder tile will be returned. When not set, the default behaviour of the imagery set takes place,\n * which is unique for each imagery set in BingMaps.\n */\n\n/**\n * @typedef {Object} BingMapsImageryMetadataResponse\n * @property {number} statusCode The response status code\n * @property {string} statusDescription The response status description\n * @property {string} authenticationResultCode The authentication result code\n * @property {Array<ResourceSet>} resourceSets The array of resource sets\n */\n\n/**\n * @typedef {Object} ResourceSet\n * @property {Array<Resource>} resources Resources.\n */\n\n/**\n * @typedef {Object} Resource\n * @property {number} imageHeight The image height\n * @property {number} imageWidth The image width\n * @property {number} zoomMin The minimum zoom level\n * @property {number} zoomMax The maximum zoom level\n * @property {string} imageUrl The image URL\n * @property {Array<string>} imageUrlSubdomains The image URL subdomains for rotation\n * @property {Array<ImageryProvider>} [imageryProviders] The array of ImageryProviders\n */\n\n/**\n * @typedef {Object} ImageryProvider\n * @property {Array<CoverageArea>} coverageAreas The coverage areas\n * @property {string} [attribution] The attribution\n */\n\n/**\n * @typedef {Object} CoverageArea\n * @property {number} zoomMin The minimum zoom\n * @property {number} zoomMax The maximum zoom\n * @property {Array<number>} bbox The coverage bounding box\n */\n\n/**\n * @classdesc\n * Layer source for Bing Maps tile data.\n * @api\n */\nclass BingMaps extends TileImage {\n  /**\n   * @param {Options} options Bing Maps options.\n   */\n  constructor(options) {\n    const hidpi = options.hidpi !== undefined ? options.hidpi : false;\n\n    super({\n      cacheSize: options.cacheSize,\n      crossOrigin: 'anonymous',\n      interpolate: options.interpolate,\n      projection: getProjection('EPSG:3857'),\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      state: 'loading',\n      tileLoadFunction: options.tileLoadFunction,\n      tilePixelRatio: hidpi ? 2 : 1,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      transition: options.transition,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hidpi_ = hidpi;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.culture_ = options.culture !== undefined ? options.culture : 'en-us';\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxZoom_ = options.maxZoom !== undefined ? options.maxZoom : -1;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.apiKey_ = options.key;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.imagerySet_ = options.imagerySet;\n\n    /**\n     * @private\n     * @type {boolean|undefined}\n     */\n    this.placeholderTiles_ = options.placeholderTiles;\n\n    const url =\n      'https://dev.virtualearth.net/REST/v1/Imagery/Metadata/' +\n      this.imagerySet_ +\n      '?uriScheme=https&include=ImageryProviders&key=' +\n      this.apiKey_ +\n      '&c=' +\n      this.culture_;\n\n    fetch(url)\n      .then((response) => response.json())\n      .then((json) => this.handleImageryMetadataResponse(json));\n  }\n\n  /**\n   * Get the api key used for this source.\n   *\n   * @return {string} The api key.\n   * @api\n   */\n  getApiKey() {\n    return this.apiKey_;\n  }\n\n  /**\n   * Get the imagery set associated with this source.\n   *\n   * @return {string} The imagery set.\n   * @api\n   */\n  getImagerySet() {\n    return this.imagerySet_;\n  }\n\n  /**\n   * @param {BingMapsImageryMetadataResponse} response Response.\n   */\n  handleImageryMetadataResponse(response) {\n    if (\n      response.statusCode != 200 ||\n      response.statusDescription != 'OK' ||\n      response.authenticationResultCode != 'ValidCredentials' ||\n      response.resourceSets.length != 1 ||\n      response.resourceSets[0].resources.length != 1\n    ) {\n      this.setState('error');\n      return;\n    }\n\n    const resource = response.resourceSets[0].resources[0];\n    const maxZoom = this.maxZoom_ == -1 ? resource.zoomMax : this.maxZoom_;\n\n    const sourceProjection = this.getProjection();\n    const extent = extentFromProjection(sourceProjection);\n    const scale = this.hidpi_ ? 2 : 1;\n    const tileSize =\n      resource.imageWidth == resource.imageHeight\n        ? resource.imageWidth / scale\n        : [resource.imageWidth / scale, resource.imageHeight / scale];\n\n    const tileGrid = createXYZ({\n      extent: extent,\n      minZoom: resource.zoomMin,\n      maxZoom: maxZoom,\n      tileSize: tileSize,\n    });\n    this.tileGrid = tileGrid;\n\n    const culture = this.culture_;\n    const hidpi = this.hidpi_;\n    const placeholderTiles = this.placeholderTiles_;\n    this.tileUrlFunction = createFromTileUrlFunctions(\n      resource.imageUrlSubdomains.map(function (subdomain) {\n        /** @type {import('../tilecoord.js').TileCoord} */\n        const quadKeyTileCoord = [0, 0, 0];\n        const imageUrl = resource.imageUrl\n          .replace('{subdomain}', subdomain)\n          .replace('{culture}', culture);\n        return (\n          /**\n           * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n           * @param {number} pixelRatio Pixel ratio.\n           * @param {import(\"../proj/Projection.js\").default} projection Projection.\n           * @return {string|undefined} Tile URL.\n           */\n          function (tileCoord, pixelRatio, projection) {\n            if (!tileCoord) {\n              return undefined;\n            }\n            createOrUpdate(\n              tileCoord[0],\n              tileCoord[1],\n              tileCoord[2],\n              quadKeyTileCoord,\n            );\n            const url = new URL(\n              imageUrl.replace('{quadkey}', quadKey(quadKeyTileCoord)),\n            );\n            const params = url.searchParams;\n            if (hidpi) {\n              params.set('dpi', 'd1');\n              params.set('device', 'mobile');\n            }\n            if (placeholderTiles === true) {\n              params.delete('n');\n            } else if (placeholderTiles === false) {\n              params.set('n', 'z');\n            }\n            return url.toString();\n          }\n        );\n      }),\n    );\n\n    if (resource.imageryProviders) {\n      const transform = getTransformFromProjections(\n        getProjection('EPSG:4326'),\n        this.getProjection(),\n      );\n\n      this.setAttributions((frameState) => {\n        const attributions = [];\n        const viewState = frameState.viewState;\n        const tileGrid = this.getTileGrid();\n        const z = tileGrid.getZForResolution(\n          viewState.resolution,\n          this.zDirection,\n        );\n        const tileCoord = tileGrid.getTileCoordForCoordAndZ(\n          viewState.center,\n          z,\n        );\n        const zoom = tileCoord[0];\n        resource.imageryProviders.map(function (imageryProvider) {\n          let intersecting = false;\n          const coverageAreas = imageryProvider.coverageAreas;\n          for (let i = 0, ii = coverageAreas.length; i < ii; ++i) {\n            const coverageArea = coverageAreas[i];\n            if (zoom >= coverageArea.zoomMin && zoom <= coverageArea.zoomMax) {\n              const bbox = coverageArea.bbox;\n              const epsg4326Extent = [bbox[1], bbox[0], bbox[3], bbox[2]];\n              const extent = applyTransform(epsg4326Extent, transform);\n              if (intersects(extent, frameState.extent)) {\n                intersecting = true;\n                break;\n              }\n            }\n          }\n          if (intersecting) {\n            attributions.push(imageryProvider.attribution);\n          }\n        });\n\n        attributions.push(TOS_ATTRIBUTION);\n        return attributions;\n      });\n    }\n\n    this.setState('ready');\n  }\n}\n\nexport default BingMaps;\n", "/**\n * @module ol/source/CartoDB\n */\n\nimport XYZ from './XYZ.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection.\n * @property {number} [maxZoom=18] Max zoom.\n * @property {number} [minZoom] Minimum zoom.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {Object} [config] If using anonymous maps, the CartoDB config to use. See\n * https://carto.com/developers/maps-api/guides/anonymous-maps/\n * for more detail.\n * If using named maps, a key-value lookup with the template parameters.\n * See https://carto.com/developers/maps-api/guides/named-maps/\n * for more detail.\n * @property {string} [map] If using named maps, this will be the name of the template to load.\n * See https://carto.com/developers/maps-api/guides/named-maps/\n * for more detail.\n * @property {string} [account] Username as used to access public Carto dashboard at https://{username}.carto.com/.\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @typedef {Object} CartoDBLayerInfo\n * @property {string} layergroupid The layer group ID\n * @property {{https: string}} cdn_url The CDN URL\n */\n\n/**\n * @classdesc\n * Layer source for the CartoDB Maps API.\n * @api\n */\nclass CartoDB extends XYZ {\n  /**\n   * @param {Options} options CartoDB options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 18,\n      minZoom: options.minZoom,\n      projection: options.projection,\n      transition: options.transition,\n      wrapX: options.wrapX,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.account_ = options.account;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.mapId_ = options.map || '';\n\n    /**\n     * @type {!Object}\n     * @private\n     */\n    this.config_ = options.config || {};\n\n    /**\n     * @type {!Object<string, CartoDBLayerInfo>}\n     * @private\n     */\n    this.templateCache_ = {};\n\n    this.initializeMap_();\n  }\n\n  /**\n   * Returns the current config.\n   * @return {!Object} The current configuration.\n   * @api\n   */\n  getConfig() {\n    return this.config_;\n  }\n\n  /**\n   * Updates the carto db config.\n   * @param {Object} config a key-value lookup. Values will replace current values\n   *     in the config.\n   * @api\n   */\n  updateConfig(config) {\n    Object.assign(this.config_, config);\n    this.initializeMap_();\n  }\n\n  /**\n   * Sets the CartoDB config\n   * @param {Object} config In the case of anonymous maps, a CartoDB configuration\n   *     object.\n   * If using named maps, a key-value lookup with the template parameters.\n   * @api\n   */\n  setConfig(config) {\n    this.config_ = config || {};\n    this.initializeMap_();\n  }\n\n  /**\n   * Issue a request to initialize the CartoDB map.\n   * @private\n   */\n  initializeMap_() {\n    const paramHash = JSON.stringify(this.config_);\n    if (this.templateCache_[paramHash]) {\n      this.applyTemplate_(this.templateCache_[paramHash]);\n      return;\n    }\n    let mapUrl = 'https://' + this.account_ + '.carto.com/api/v1/map';\n\n    if (this.mapId_) {\n      mapUrl += '/named/' + this.mapId_;\n    }\n\n    const client = new XMLHttpRequest();\n    client.addEventListener(\n      'load',\n      this.handleInitResponse_.bind(this, paramHash),\n    );\n    client.addEventListener('error', this.handleInitError_.bind(this));\n    client.open('POST', mapUrl);\n    client.setRequestHeader('Content-type', 'application/json');\n    client.send(JSON.stringify(this.config_));\n  }\n\n  /**\n   * Handle map initialization response.\n   * @param {string} paramHash a hash representing the parameter set that was used\n   *     for the request\n   * @param {Event} event Event.\n   * @private\n   */\n  handleInitResponse_(paramHash, event) {\n    const client = /** @type {XMLHttpRequest} */ (event.target);\n    // status will be 0 for file:// urls\n    if (!client.status || (client.status >= 200 && client.status < 300)) {\n      let response;\n      try {\n        response = /** @type {CartoDBLayerInfo} */ (\n          JSON.parse(client.responseText)\n        );\n      } catch (err) {\n        this.setState('error');\n        return;\n      }\n      this.applyTemplate_(response);\n      this.templateCache_[paramHash] = response;\n      this.setState('ready');\n    } else {\n      this.setState('error');\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event Event.\n   */\n  handleInitError_(event) {\n    this.setState('error');\n  }\n\n  /**\n   * Apply the new tile urls returned by carto db\n   * @param {CartoDBLayerInfo} data Result of carto db call.\n   * @private\n   */\n  applyTemplate_(data) {\n    const tilesUrl =\n      'https://' +\n      data.cdn_url.https +\n      '/' +\n      this.account_ +\n      '/api/v1/map/' +\n      data.layergroupid +\n      '/{z}/{x}/{y}.png';\n    this.setUrl(tilesUrl);\n  }\n}\n\nexport default CartoDB;\n", "/**\n * @module ol/source/Cluster\n */\n\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport Point from '../geom/Point.js';\nimport VectorSource from './Vector.js';\nimport {add as addCoordinate, scale as scaleCoordinate} from '../coordinate.js';\nimport {assert} from '../asserts.js';\nimport {\n  buffer,\n  createEmpty,\n  createOrUpdateFromCoordinate,\n  getCenter,\n} from '../extent.js';\nimport {getUid} from '../util.js';\n\n/**\n * @template {import(\"../Feature.js\").FeatureLike} FeatureType\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [distance=20] Distance in pixels within which features will\n * be clustered together.\n * @property {number} [minDistance=0] Minimum distance in pixels between clusters.\n * Will be capped at the configured distance.\n * By default no minimum distance is guaranteed. This config can be used to avoid\n * overlapping icons. As a tradoff, the cluster feature's position will no longer be\n * the center of all its features.\n * @property {function(FeatureType):(Point|null)} [geometryFunction]\n * Function that takes a {@link module:ol/Feature~Feature} as argument and returns a\n * {@link module:ol/geom/Point~Point} as cluster calculation point for the feature. When a\n * feature should not be considered for clustering, the function should return\n * `null`. The default, which works when the underlying source contains point\n * features only, is\n * ```js\n * function(feature) {\n *   return feature.getGeometry();\n * }\n * ```\n * See {@link module:ol/geom/Polygon~Polygon#getInteriorPoint} for a way to get a cluster\n * calculation point for polygons.\n * @property {function(Point, Array<FeatureType>):Feature} [createCluster]\n * Function that takes the cluster's center {@link module:ol/geom/Point~Point} and an array\n * of {@link module:ol/Feature~Feature} included in this cluster. Must return a\n * {@link module:ol/Feature~Feature} that will be used to render. Default implementation is:\n * ```js\n * function(point, features) {\n *   return new Feature({\n *     geometry: point,\n *     features: features\n *   });\n * }\n * ```\n * @property {VectorSource<FeatureType>} [source=null] Source.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n */\n\n/**\n * @classdesc\n * Layer source to cluster vector data. Works out of the box with point\n * geometries. For other geometry types, or if not all geometries should be\n * considered for clustering, a custom `geometryFunction` can be defined.\n *\n * If the instance is disposed without also disposing the underlying\n * source `setSource(null)` has to be called to remove the listener reference\n * from the wrapped source.\n * @api\n * @template {import('../Feature.js').FeatureLike} FeatureType\n * @extends {VectorSource<Feature<import(\"../geom/Geometry.js\").default>>}\n */\nclass Cluster extends VectorSource {\n  /**\n   * @param {Options<FeatureType>} [options] Cluster options.\n   */\n  constructor(options) {\n    options = options || {};\n    super({\n      attributions: options.attributions,\n      wrapX: options.wrapX,\n    });\n\n    /**\n     * @type {number|undefined}\n     * @protected\n     */\n    this.resolution = undefined;\n\n    /**\n     * @type {number}\n     * @protected\n     */\n    this.distance = options.distance !== undefined ? options.distance : 20;\n\n    /**\n     * @type {number}\n     * @protected\n     */\n    this.minDistance = options.minDistance || 0;\n\n    /**\n     * @type {number}\n     * @protected\n     */\n    this.interpolationRatio = 0;\n\n    /**\n     * @type {Array<Feature>}\n     * @protected\n     */\n    this.features = [];\n\n    /**\n     * @param {FeatureType} feature Feature.\n     * @return {Point} Cluster calculation point.\n     * @protected\n     */\n    this.geometryFunction =\n      options.geometryFunction ||\n      function (feature) {\n        const geometry = /** @type {Point} */ (feature.getGeometry());\n        assert(\n          !geometry || geometry.getType() === 'Point',\n          'The default `geometryFunction` can only handle `Point` or null geometries',\n        );\n        return geometry;\n      };\n\n    /**\n     * @type {function(Point, Array<FeatureType>):Feature}\n     * @private\n     */\n    this.createCustomCluster_ = options.createCluster;\n\n    /**\n     * @type {VectorSource<FeatureType>|null}\n     * @protected\n     */\n    this.source = null;\n\n    /**\n     * @private\n     */\n    this.boundRefresh_ = this.refresh.bind(this);\n\n    this.updateDistance(this.distance, this.minDistance);\n    this.setSource(options.source || null);\n  }\n\n  /**\n   * Remove all features from the source.\n   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/VectorEventType~VectorEventType#removefeature} events.\n   * @api\n   * @override\n   */\n  clear(fast) {\n    this.features.length = 0;\n    super.clear(fast);\n  }\n\n  /**\n   * Get the distance in pixels between clusters.\n   * @return {number} Distance.\n   * @api\n   */\n  getDistance() {\n    return this.distance;\n  }\n\n  /**\n   * Get a reference to the wrapped source.\n   * @return {VectorSource<FeatureType>|null} Source.\n   * @api\n   */\n  getSource() {\n    return this.source;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @override\n   */\n  loadFeatures(extent, resolution, projection) {\n    this.source?.loadFeatures(extent, resolution, projection);\n    if (resolution !== this.resolution) {\n      this.resolution = resolution;\n      this.refresh();\n    }\n  }\n\n  /**\n   * Set the distance within which features will be clusterd together.\n   * @param {number} distance The distance in pixels.\n   * @api\n   */\n  setDistance(distance) {\n    this.updateDistance(distance, this.minDistance);\n  }\n\n  /**\n   * Set the minimum distance between clusters. Will be capped at the\n   * configured distance.\n   * @param {number} minDistance The minimum distance in pixels.\n   * @api\n   */\n  setMinDistance(minDistance) {\n    this.updateDistance(this.distance, minDistance);\n  }\n\n  /**\n   * The configured minimum distance between clusters.\n   * @return {number} The minimum distance in pixels.\n   * @api\n   */\n  getMinDistance() {\n    return this.minDistance;\n  }\n\n  /**\n   * Replace the wrapped source.\n   * @param {VectorSource<FeatureType>|null} source The new source for this instance.\n   * @api\n   */\n  setSource(source) {\n    if (this.source) {\n      this.source.removeEventListener(EventType.CHANGE, this.boundRefresh_);\n    }\n    this.source = source;\n    if (source) {\n      source.addEventListener(EventType.CHANGE, this.boundRefresh_);\n    }\n    this.refresh();\n  }\n\n  /**\n   * Handle the source changing.\n   * @override\n   */\n  refresh() {\n    this.clear();\n    this.cluster();\n    this.addFeatures(this.features);\n  }\n\n  /**\n   * Update the distances and refresh the source if necessary.\n   * @param {number} distance The new distance.\n   * @param {number} minDistance The new minimum distance.\n   */\n  updateDistance(distance, minDistance) {\n    const ratio =\n      distance === 0 ? 0 : Math.min(minDistance, distance) / distance;\n    const changed =\n      distance !== this.distance || this.interpolationRatio !== ratio;\n    this.distance = distance;\n    this.minDistance = minDistance;\n    this.interpolationRatio = ratio;\n    if (changed) {\n      this.refresh();\n    }\n  }\n\n  /**\n   * @protected\n   */\n  cluster() {\n    if (this.resolution === undefined || !this.source) {\n      return;\n    }\n    const extent = createEmpty();\n    const mapDistance = this.distance * this.resolution;\n    const features = this.source.getFeatures();\n\n    /** @type {Object<string, true>} */\n    const clustered = {};\n\n    for (let i = 0, ii = features.length; i < ii; i++) {\n      const feature = features[i];\n      if (!(getUid(feature) in clustered)) {\n        const geometry = this.geometryFunction(feature);\n        if (geometry) {\n          const coordinates = geometry.getCoordinates();\n          createOrUpdateFromCoordinate(coordinates, extent);\n          buffer(extent, mapDistance, extent);\n\n          const neighbors = this.source\n            .getFeaturesInExtent(extent)\n            .filter(function (neighbor) {\n              const uid = getUid(neighbor);\n              if (uid in clustered) {\n                return false;\n              }\n              clustered[uid] = true;\n              return true;\n            });\n          this.features.push(this.createCluster(neighbors, extent));\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Array<FeatureType>} features Features\n   * @param {import(\"../extent.js\").Extent} extent The searched extent for these features.\n   * @return {Feature} The cluster feature.\n   * @protected\n   */\n  createCluster(features, extent) {\n    const centroid = [0, 0];\n    for (let i = features.length - 1; i >= 0; --i) {\n      const geometry = this.geometryFunction(features[i]);\n      if (geometry) {\n        addCoordinate(centroid, geometry.getCoordinates());\n      } else {\n        features.splice(i, 1);\n      }\n    }\n    scaleCoordinate(centroid, 1 / features.length);\n    const searchCenter = getCenter(extent);\n    const ratio = this.interpolationRatio;\n    const geometry = new Point([\n      centroid[0] * (1 - ratio) + searchCenter[0] * ratio,\n      centroid[1] * (1 - ratio) + searchCenter[1] * ratio,\n    ]);\n    if (this.createCustomCluster_) {\n      return this.createCustomCluster_(geometry, features);\n    }\n    return new Feature({\n      geometry,\n      features,\n    });\n  }\n}\n\nexport default Cluster;\n", "/**\n * @module ol/source/DataTile\n */\nimport DataTile from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport ReprojDataTile from '../reproj/DataTile.js';\nimport TileEventType from './TileEventType.js';\nimport TileSource, {TileSourceEvent} from './Tile.js';\nimport TileState from '../TileState.js';\nimport {\n  createXYZ,\n  extentFromProjection,\n  getForProjection as getTileGridForProjection,\n} from '../tilegrid.js';\nimport {equivalent, get as getProjection} from '../proj.js';\nimport {getUid} from '../util.js';\nimport {toPromise} from '../functions.js';\nimport {toSize} from '../size.js';\n\n/**\n * @typedef {'anonymous'|'use-credentials'} CrossOriginAttribute\n */\n\n/**\n * @typedef {Object} LoaderOptions\n * @property {AbortSignal} signal An abort controller signal.\n * @property {CrossOriginAttribute} [crossOrigin] The cross-origin attribute for images.\n * @property {number} [maxY] The maximum y coordinate at the given z level.  Will be undefined if the\n * underlying tile grid does not have a known extent.\n */\n\n/**\n * Data tile loading function.  The function is called with z, x, and y tile coordinates and\n * returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * @typedef {function(number, number, number, LoaderOptions) : (import(\"../DataTile.js\").Data|Promise<import(\"../DataTile.js\").Data>)} Loader\n */\n\n/**\n * @typedef {Object} Options\n * @property {Loader} [loader] Data loader.  Called with z, x, and y tile coordinates.\n * Returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * For loaders that generate images, the promise should not resolve until the image is loaded.\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The pixel width and height of the source tiles.\n * This may be different than the rendered pixel size if a `tileGrid` is provided.\n * @property {number} [gutter=0] The size in pixels of the gutter around data tiles to ignore.\n * This allows artifacts of rendering at tile edges to be ignored.\n * Supported data should be wider and taller than the tile size by a value of `2 x gutter`.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Tile projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"./Source.js\").State} [state] The source state.\n * @property {boolean} [wrapX=false] Render tiles beyond the antimeridian.\n * @property {number} [transition] Transition time when fading in new tiles (in milliseconds).\n * @property {number} [bandCount=4] Number of bands represented in the data.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {CrossOriginAttribute} [crossOrigin='anonymous'] The crossOrigin property to pass to loaders for image data.\n * @property {string} [key] Key for use in caching tiles.\n */\n\n/**\n * @classdesc\n * A source for typed array data tiles.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @template {import(\"../Tile.js\").default} [TileType=DataTile]\n * @extends TileSource<TileType>\n * @api\n */\nclass DataTileSource extends TileSource {\n  /**\n   * @param {Options} options DataTile source options.\n   */\n  constructor(options) {\n    const projection =\n      options.projection === undefined ? 'EPSG:3857' : options.projection;\n\n    let tileGrid = options.tileGrid;\n    if (tileGrid === undefined && projection) {\n      tileGrid = createXYZ({\n        extent: extentFromProjection(projection),\n        maxResolution: options.maxResolution,\n        maxZoom: options.maxZoom,\n        minZoom: options.minZoom,\n        tileSize: options.tileSize,\n      });\n    }\n\n    super({\n      cacheSize: 0.1, // don't cache on the source\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: projection,\n      tileGrid: tileGrid,\n      state: options.state,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      interpolate: options.interpolate,\n      key: options.key,\n    });\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter !== undefined ? options.gutter : 0;\n\n    /**\n     * @private\n     * @type {import('../size.js').Size|null}\n     */\n    this.tileSize_ = options.tileSize ? toSize(options.tileSize) : null;\n\n    /**\n     * @private\n     * @type {Array<import('../size.js').Size>|null}\n     */\n    this.tileSizes_ = null;\n\n    /**\n     * @private\n     * @type {!Object<string, boolean>}\n     */\n    this.tileLoadingKeys_ = {};\n\n    /**\n     * @private\n     */\n    this.loader_ = options.loader;\n\n    /**\n     * @private\n     */\n    this.handleTileChange_ = this.handleTileChange_.bind(this);\n\n    /**\n     * @type {number}\n     */\n    this.bandCount = options.bandCount === undefined ? 4 : options.bandCount; // assume RGBA if undefined\n\n    /**\n     * @private\n     * @type {!Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    this.tileGridForProjection_ = {};\n\n    /**\n     * @private\n     * @type {CrossOriginAttribute}\n     */\n    this.crossOrigin_ = options.crossOrigin || 'anonymous';\n  }\n\n  /**\n   * Set the source tile sizes.  The length of the array is expected to match the number of\n   * levels in the tile grid.\n   * @protected\n   * @param {Array<import('../size.js').Size>} tileSizes An array of tile sizes.\n   */\n  setTileSizes(tileSizes) {\n    this.tileSizes_ = tileSizes;\n  }\n\n  /**\n   * Get the source tile size at the given zoom level.  This may be different than the rendered tile\n   * size.\n   * @protected\n   * @param {number} z Tile zoom level.\n   * @return {import('../size.js').Size} The source tile size.\n   */\n  getTileSize(z) {\n    if (this.tileSizes_) {\n      return this.tileSizes_[z];\n    }\n    if (this.tileSize_) {\n      return this.tileSize_;\n    }\n    const tileGrid = this.getTileGrid();\n    return tileGrid ? toSize(tileGrid.getTileSize(z)) : [256, 256];\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   * @override\n   */\n  getGutterForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (!thisProj || equivalent(thisProj, projection)) {\n      return this.gutter_;\n    }\n\n    return 0;\n  }\n\n  /**\n   * @param {Loader} loader The data loader.\n   * @protected\n   */\n  setLoader(loader) {\n    this.loader_ = loader;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../proj/Projection.js\").default} targetProj The output projection.\n   * @param {import(\"../proj/Projection.js\").default} sourceProj The input projection.\n   * @return {!TileType} Tile.\n   */\n  getReprojTile_(z, x, y, targetProj, sourceProj) {\n    const tileGrid = this.getTileGrid();\n    const reprojTilePixelRatio = Math.max.apply(\n      null,\n      tileGrid.getResolutions().map((r, z) => {\n        const tileSize = toSize(tileGrid.getTileSize(z));\n        const textureSize = this.getTileSize(z);\n        return Math.max(\n          textureSize[0] / tileSize[0],\n          textureSize[1] / tileSize[1],\n        );\n      }),\n    );\n\n    const sourceTileGrid = this.getTileGridForProjection(sourceProj);\n    const targetTileGrid = this.getTileGridForProjection(targetProj);\n    const tileCoord = [z, x, y];\n    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      targetProj,\n    );\n\n    const options = Object.assign(\n      {\n        sourceProj,\n        sourceTileGrid,\n        targetProj,\n        targetTileGrid,\n        tileCoord,\n        wrappedTileCoord,\n        pixelRatio: reprojTilePixelRatio,\n        gutter: this.getGutterForProjection(sourceProj),\n        getTileFunction: (z, x, y, pixelRatio) =>\n          this.getTile(z, x, y, pixelRatio, sourceProj),\n      },\n      /** @type {import(\"../reproj/DataTile.js\").Options} */ (this.tileOptions),\n    );\n    const tile = /** @type {TileType} */ (\n      /** @type {*} */ (new ReprojDataTile(options))\n    );\n    tile.key = this.getKey();\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {TileType|null} Tile (or null if outside source extent).\n   * @override\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const sourceProjection = this.getProjection();\n    if (\n      sourceProjection &&\n      projection &&\n      !equivalent(sourceProjection, projection)\n    ) {\n      return this.getReprojTile_(z, x, y, projection, sourceProjection);\n    }\n\n    const size = this.getTileSize(z);\n\n    const sourceLoader = this.loader_;\n\n    const controller = new AbortController();\n\n    /**\n     * @type {LoaderOptions}\n     */\n    const loaderOptions = {\n      signal: controller.signal,\n      crossOrigin: this.crossOrigin_,\n    };\n\n    const tileCoord = this.getTileCoordForTileUrlFunction([z, x, y]);\n    if (!tileCoord) {\n      return null;\n    }\n\n    const requestZ = tileCoord[0];\n    const requestX = tileCoord[1];\n    const requestY = tileCoord[2];\n    function loader() {\n      return toPromise(function () {\n        return sourceLoader(requestZ, requestX, requestY, loaderOptions);\n      });\n    }\n\n    /**\n     * @type {import(\"../DataTile.js\").Options}\n     */\n    const options = Object.assign(\n      {\n        tileCoord: [z, x, y],\n        loader: loader,\n        size: size,\n        controller: controller,\n      },\n      this.tileOptions,\n    );\n\n    const tile = /** @type {TileType} */ (\n      /** @type {*} */ (new DataTile(options))\n    );\n    tile.key = this.getKey();\n    tile.addEventListener(EventType.CHANGE, this.handleTileChange_);\n\n    return tile;\n  }\n\n  /**\n   * Handle tile change events.\n   * @param {import(\"../events/Event.js\").default} event Event.\n   */\n  handleTileChange_(event) {\n    const tile = /** @type {import(\"../Tile.js\").default} */ (event.target);\n    const uid = getUid(tile);\n    const tileState = tile.getState();\n    let type;\n    if (tileState == TileState.LOADING) {\n      this.tileLoadingKeys_[uid] = true;\n      type = TileEventType.TILELOADSTART;\n    } else if (uid in this.tileLoadingKeys_) {\n      delete this.tileLoadingKeys_[uid];\n      type =\n        tileState == TileState.ERROR\n          ? TileEventType.TILELOADERROR\n          : tileState == TileState.LOADED\n            ? TileEventType.TILELOADEND\n            : undefined;\n    }\n    if (type) {\n      this.dispatchEvent(new TileSourceEvent(type, tile));\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   * @override\n   */\n  getTileGridForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {\n      return this.tileGrid;\n    }\n\n    const projKey = getUid(projection);\n    if (!(projKey in this.tileGridForProjection_)) {\n      this.tileGridForProjection_[projKey] =\n        getTileGridForProjection(projection);\n    }\n    return this.tileGridForProjection_[projKey];\n  }\n\n  /**\n   * Sets the tile grid to use when reprojecting the tiles to the given\n   * projection instead of the default tile grid for the projection.\n   *\n   * This can be useful when the default tile grid cannot be created\n   * (e.g. projection has no extent defined) or\n   * for optimization reasons (custom tile size, resolutions, ...).\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tilegrid Tile grid to use for the projection.\n   * @api\n   */\n  setTileGridForProjection(projection, tilegrid) {\n    const proj = getProjection(projection);\n    if (proj) {\n      const projKey = getUid(proj);\n      if (!(projKey in this.tileGridForProjection_)) {\n        this.tileGridForProjection_[projKey] = tilegrid;\n      }\n    }\n  }\n}\n\nexport default DataTileSource;\n", "/**\n * @module ol/source/GeoTIFF\n */\nimport DataTile from './DataTile.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport {\n  Pool,\n  globals as geotiffGlobals,\n  fromBlob as tiffFromBlob,\n  fromUrl as tiffFromUrl,\n  fromUrls as tiffFromUrls,\n} from 'geotiff';\nimport {\n  Projection,\n  get as getCachedProjection,\n  toUserCoordinate,\n  toUserExtent,\n} from '../proj.js';\nimport {clamp} from '../math.js';\nimport {getCenter, getIntersection} from '../extent.js';\nimport {error as logError} from '../console.js';\nimport {fromCode as unitsFromCode} from '../proj/Units.js';\n\n/**\n * Determine if an image type is a mask.\n * See https://www.awaresystems.be/imaging/tiff/tifftags/newsubfiletype.html\n * @param {GeoTIFFImage} image The image.\n * @return {boolean} The image is a mask.\n */\nfunction isMask(image) {\n  const fileDirectory = image.fileDirectory;\n  const type = fileDirectory.NewSubfileType || 0;\n  return (type & 4) === 4;\n}\n\n/**\n * @param {true|false|'auto'} preference The convertToRGB option.\n * @param {GeoTIFFImage} image The image.\n * @return {boolean} Use the `image.readRGB()` method.\n */\nfunction readRGB(preference, image) {\n  if (!preference) {\n    return false;\n  }\n  if (preference === true) {\n    return true;\n  }\n  if (image.getSamplesPerPixel() !== 3) {\n    return false;\n  }\n  const interpretation = image.fileDirectory.PhotometricInterpretation;\n  const interpretations = geotiffGlobals.photometricInterpretations;\n  return (\n    interpretation === interpretations.CMYK ||\n    interpretation === interpretations.YCbCr ||\n    interpretation === interpretations.CIELab ||\n    interpretation === interpretations.ICCLab\n  );\n}\n\n/**\n * @typedef {Object} SourceInfo\n * @property {string} [url] URL for the source GeoTIFF.\n * @property {Array<string>} [overviews] List of any overview URLs, only applies if the url parameter is given.\n * @property {Blob} [blob] Blob containing the source GeoTIFF. `blob` and `url` are mutually exclusive.\n * @property {number} [min=0] The minimum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the minimum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [max] The maximum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the maximum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [nodata] Values to discard (overriding any nodata values in the metadata).\n * When provided, an additional alpha band will be added to the data.  Often the GeoTIFF metadata\n * will include information about nodata values, so you should only need to set this property if\n * you find that it is not already extracted from the metadata.\n * @property {Array<number>} [bands] Band numbers to be read from (where the first band is `1`). If not provided, all bands will\n * be read. For example, if a GeoTIFF has blue (1), green (2), red (3), and near-infrared (4) bands, and you only need the\n * near-infrared band, configure `bands: [4]`.\n */\n\n/**\n * @typedef {Object} GeoKeys\n * @property {number} GTModelTypeGeoKey Model type.\n * @property {number} GTRasterTypeGeoKey Raster type.\n * @property {number} GeogAngularUnitsGeoKey Angular units.\n * @property {number} GeogInvFlatteningGeoKey Inverse flattening.\n * @property {number} GeogSemiMajorAxisGeoKey Semi-major axis.\n * @property {number} GeographicTypeGeoKey Geographic coordinate system code.\n * @property {number} ProjLinearUnitsGeoKey Projected linear unit code.\n * @property {number} ProjectedCSTypeGeoKey Projected coordinate system code.\n */\n\n/**\n * @typedef {import(\"geotiff\").GeoTIFF} GeoTIFF\n */\n\n/**\n * @typedef {import(\"geotiff\").MultiGeoTIFF} MultiGeoTIFF\n */\n\n/**\n * @typedef {Object} GDALMetadata\n * @property {string} STATISTICS_MINIMUM The minimum value (as a string).\n * @property {string} STATISTICS_MAXIMUM The maximum value (as a string).\n */\n\nconst STATISTICS_MAXIMUM = 'STATISTICS_MAXIMUM';\nconst STATISTICS_MINIMUM = 'STATISTICS_MINIMUM';\n\nconst defaultTileSize = 256;\n\n/**\n * @typedef {import(\"geotiff\").GeoTIFFImage} GeoTIFFImage\n */\n\nlet workerPool;\nfunction getWorkerPool() {\n  if (!workerPool) {\n    workerPool = new Pool();\n  }\n  return workerPool;\n}\n\n/**\n * Get the bounding box of an image.  If the image does not have an affine transform,\n * the pixel bounds are returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image bounding box.\n */\nfunction getBoundingBox(image) {\n  try {\n    return image.getBoundingBox();\n  } catch (_) {\n    return [0, 0, image.getWidth(), image.getHeight()];\n  }\n}\n\n/**\n * Get the origin of an image.  If the image does not have an affine transform,\n * the top-left corner of the pixel bounds is returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image origin.\n */\nfunction getOrigin(image) {\n  try {\n    return image.getOrigin().slice(0, 2);\n  } catch (_) {\n    return [0, image.getHeight()];\n  }\n}\n\n/**\n * Get the resolution of an image.  If the image does not have an affine transform,\n * the width of the image is compared with the reference image.\n * @param {GeoTIFFImage} image The image.\n * @param {GeoTIFFImage} referenceImage The reference image.\n * @return {Array<number>} The map x and y units per pixel.\n */\nfunction getResolutions(image, referenceImage) {\n  try {\n    return image.getResolution(referenceImage);\n  } catch (_) {\n    return [\n      referenceImage.getWidth() / image.getWidth(),\n      referenceImage.getHeight() / image.getHeight(),\n    ];\n  }\n}\n\n/**\n * @param {GeoTIFFImage} image A GeoTIFF.\n * @return {import(\"../proj/Projection.js\").default} The image projection.\n */\nfunction getProjection(image) {\n  const geoKeys = image.geoKeys;\n  if (!geoKeys) {\n    return null;\n  }\n\n  if (\n    geoKeys.ProjectedCSTypeGeoKey &&\n    geoKeys.ProjectedCSTypeGeoKey !== 32767\n  ) {\n    const code = 'EPSG:' + geoKeys.ProjectedCSTypeGeoKey;\n    let projection = getCachedProjection(code);\n    if (!projection) {\n      const units = unitsFromCode(geoKeys.ProjLinearUnitsGeoKey);\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units,\n        });\n      }\n    }\n    return projection;\n  }\n\n  if (geoKeys.GeographicTypeGeoKey && geoKeys.GeographicTypeGeoKey !== 32767) {\n    const code = 'EPSG:' + geoKeys.GeographicTypeGeoKey;\n    let projection = getCachedProjection(code);\n    if (!projection) {\n      const units = unitsFromCode(geoKeys.GeogAngularUnitsGeoKey);\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units,\n        });\n      }\n    }\n    return projection;\n  }\n\n  return null;\n}\n\n/**\n * @param {GeoTIFF|MultiGeoTIFF} tiff A GeoTIFF.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForTIFF(tiff) {\n  return tiff.getImageCount().then(function (count) {\n    const requests = new Array(count);\n    for (let i = 0; i < count; ++i) {\n      requests[i] = tiff.getImage(i);\n    }\n    return Promise.all(requests);\n  });\n}\n\n/**\n * @param {SourceInfo} source The GeoTIFF source.\n * @param {Object} options Options for the GeoTIFF source.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForSource(source, options) {\n  let request;\n  if (source.blob) {\n    request = tiffFromBlob(source.blob);\n  } else if (source.overviews) {\n    request = tiffFromUrls(source.url, source.overviews, options);\n  } else {\n    request = tiffFromUrl(source.url, options);\n  }\n  return request.then(getImagesForTIFF);\n}\n\n/**\n * @param {number|Array<number>|Array<Array<number>>} expected Expected value.\n * @param {number|Array<number>|Array<Array<number>>} got Actual value.\n * @param {number} tolerance Accepted tolerance in fraction of expected between expected and got.\n * @param {string} message The error message.\n * @param {function(Error):void} rejector A function to be called with any error.\n */\nfunction assertEqual(expected, got, tolerance, message, rejector) {\n  if (Array.isArray(expected)) {\n    const length = expected.length;\n    if (!Array.isArray(got) || length != got.length) {\n      const error = new Error(message);\n      rejector(error);\n      throw error;\n    }\n    for (let i = 0; i < length; ++i) {\n      assertEqual(expected[i], got[i], tolerance, message, rejector);\n    }\n    return;\n  }\n\n  got = /** @type {number} */ (got);\n  if (Math.abs(expected - got) > tolerance * expected) {\n    throw new Error(message);\n  }\n}\n\n/**\n * @param {Array} array The data array.\n * @return {number} The minimum value.\n */\nfunction getMinForDataType(array) {\n  if (array instanceof Int8Array) {\n    return -128;\n  }\n  if (array instanceof Int16Array) {\n    return -32768;\n  }\n  if (array instanceof Int32Array) {\n    return -2147483648;\n  }\n  if (array instanceof Float32Array) {\n    return 1.2e-38;\n  }\n  return 0;\n}\n\n/**\n * @param {Array} array The data array.\n * @return {number} The maximum value.\n */\nfunction getMaxForDataType(array) {\n  if (array instanceof Int8Array) {\n    return 127;\n  }\n  if (array instanceof Uint8Array) {\n    return 255;\n  }\n  if (array instanceof Uint8ClampedArray) {\n    return 255;\n  }\n  if (array instanceof Int16Array) {\n    return 32767;\n  }\n  if (array instanceof Uint16Array) {\n    return 65535;\n  }\n  if (array instanceof Int32Array) {\n    return 2147483647;\n  }\n  if (array instanceof Uint32Array) {\n    return 4294967295;\n  }\n  if (array instanceof Float32Array) {\n    return 3.4e38;\n  }\n  return 255;\n}\n\n/**\n * @typedef {Object} GeoTIFFSourceOptions\n * @property {boolean} [forceXHR=false] Whether to force the usage of the browsers XMLHttpRequest API.\n * @property {Object<string, string>} [headers] additional key-value pairs of headers to be passed with each request. Key is the header name, value the header value.\n * @property {string} [credentials] How credentials shall be handled. See\n * https://developer.mozilla.org/en-US/docs/Web/API/fetch for reference and possible values\n * @property {number} [maxRanges] The maximum amount of ranges to request in a single multi-range request.\n * By default only a single range is used.\n * @property {boolean} [allowFullFile=false] Whether or not a full file is accepted when only a portion is\n * requested. Only use this when you know the source image to be small enough to fit in memory.\n * @property {number} [blockSize=65536] The block size to use.\n * @property {number} [cacheSize=100] The number of blocks that shall be held in a LRU cache.\n */\n\n/**\n * @typedef {Object} Options\n * @property {Array<SourceInfo>} sources List of information about GeoTIFF sources.\n * Multiple sources can be combined when their resolution sets are equal after applying a scale.\n * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and\n * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,\n * use the {@link import(\"./GeoTIFF.js\").SourceInfo bands} property. If, for example, you specify two\n * sources, one with 3 bands and {@link import(\"./GeoTIFF.js\").SourceInfo nodata} configured, and\n * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha\n * band from the first source, and 1 band from the second source.\n * @property {GeoTIFFSourceOptions} [sourceOptions] Additional options to be passed to [geotiff.js](https://geotiffjs.github.io/geotiff.js/module-geotiff.html)'s `fromUrl` or `fromUrls` methods.\n * @property {true|false|'auto'} [convertToRGB=false] By default, bands from the sources are read as-is. When\n * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will\n * convert other color spaces (YCbCr, CMYK) to RGB.  Setting the option to `'auto'` will make it so CMYK, YCbCr,\n * CIELab, and ICCLab images will automatically be converted to RGB.\n * @property {boolean} [normalize=true] By default, the source data is normalized to values between\n * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.\n * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option\n * to `false` will make it so any `min` and `max` properties on sources are ignored.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Source projection.  If not provided, the GeoTIFF metadata\n * will be read for projection information.\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {boolean} [wrapX=false] Render tiles beyond the tile grid extent.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.\n */\n\n/**\n * @classdesc\n * A source for working with GeoTIFF data.\n * **Note for users of the full build**: The `GeoTIFF` source requires the\n * [geotiff.js](https://github.com/geotiffjs/geotiff.js) library to be loaded as well.\n *\n * @api\n */\nclass GeoTIFFSource extends DataTile {\n  /**\n   * @param {Options} options Data tile options.\n   */\n  constructor(options) {\n    super({\n      state: 'loading',\n      tileGrid: null,\n      projection: options.projection || null,\n      transition: options.transition,\n      interpolate: options.interpolate !== false,\n      wrapX: options.wrapX,\n    });\n\n    /**\n     * @type {Array<SourceInfo>}\n     * @private\n     */\n    this.sourceInfo_ = options.sources;\n\n    const numSources = this.sourceInfo_.length;\n\n    /**\n     * @type {Object}\n     * @private\n     */\n    this.sourceOptions_ = options.sourceOptions;\n\n    /**\n     * @type {Array<Array<GeoTIFFImage>>}\n     * @private\n     */\n    this.sourceImagery_ = new Array(numSources);\n\n    /**\n     * @type {Array<Array<GeoTIFFImage>>}\n     * @private\n     */\n    this.sourceMasks_ = new Array(numSources);\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.resolutionFactors_ = new Array(numSources);\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.samplesPerPixel_;\n\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    this.nodataValues_;\n\n    /**\n     * @type {Array<Array<GDALMetadata>>}\n     * @private\n     */\n    this.metadata_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.normalize_ = options.normalize !== false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.addAlpha_ = false;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.error_ = null;\n\n    /**\n     * @type {true|false|'auto'}\n     * @private\n     */\n    this.convertToRGB_ = options.convertToRGB || false;\n\n    this.setKey(this.sourceInfo_.map((source) => source.url).join(','));\n\n    const self = this;\n    const requests = new Array(numSources);\n    for (let i = 0; i < numSources; ++i) {\n      requests[i] = getImagesForSource(\n        this.sourceInfo_[i],\n        this.sourceOptions_,\n      );\n    }\n    Promise.all(requests)\n      .then(function (sources) {\n        self.configure_(sources);\n      })\n      .catch(function (error) {\n        logError(error);\n        self.error_ = error;\n        self.setState('error');\n      });\n  }\n\n  /**\n   * @return {Error} A source loading error. When the source state is `error`, use this function\n   * to get more information about the error. To debug a faulty configuration, you may want to use\n   * a listener like\n   * ```js\n   * geotiffSource.on('change', () => {\n   *   if (geotiffSource.getState() === 'error') {\n   *     console.error(geotiffSource.getError());\n   *   }\n   * });\n   * ```\n   */\n  getError() {\n    return this.error_;\n  }\n\n  /**\n   * Determine the projection of the images in this GeoTIFF.\n   * The default implementation looks at the ProjectedCSTypeGeoKey and the GeographicTypeGeoKey\n   * of each image in turn.\n   * You can override this method in a subclass to support more projections.\n   *\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n   * from a single GeoTIFF.\n   */\n  determineProjection(sources) {\n    const firstSource = sources[0];\n    for (let i = firstSource.length - 1; i >= 0; --i) {\n      const image = firstSource[i];\n      const projection = getProjection(image);\n      if (projection) {\n        this.projection = projection;\n        break;\n      }\n    }\n  }\n\n  /**\n   * Configure the tile grid based on images within the source GeoTIFFs.  Each GeoTIFF\n   * must have the same internal tiled structure.\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n   * from a single GeoTIFF.\n   * @private\n   */\n  configure_(sources) {\n    let extent;\n    let origin;\n    let commonRenderTileSizes;\n    let commonSourceTileSizes;\n    let resolutions;\n    const samplesPerPixel = new Array(sources.length);\n    const nodataValues = new Array(sources.length);\n    const metadata = new Array(sources.length);\n    let minZoom = 0;\n\n    const sourceCount = sources.length;\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      const images = [];\n      const masks = [];\n      sources[sourceIndex].forEach((item) => {\n        if (isMask(item)) {\n          masks.push(item);\n        } else {\n          images.push(item);\n        }\n      });\n\n      const imageCount = images.length;\n      if (masks.length > 0 && masks.length !== imageCount) {\n        throw new Error(\n          `Expected one mask per image found ${masks.length} masks and ${imageCount} images`,\n        );\n      }\n\n      let sourceExtent;\n      let sourceOrigin;\n      const sourceTileSizes = new Array(imageCount);\n      const renderTileSizes = new Array(imageCount);\n      const sourceResolutions = new Array(imageCount);\n\n      nodataValues[sourceIndex] = new Array(imageCount);\n      metadata[sourceIndex] = new Array(imageCount);\n\n      for (let imageIndex = 0; imageIndex < imageCount; ++imageIndex) {\n        const image = images[imageIndex];\n        const nodataValue = image.getGDALNoData();\n        metadata[sourceIndex][imageIndex] = image.getGDALMetadata(0);\n        nodataValues[sourceIndex][imageIndex] = nodataValue;\n\n        const wantedSamples = this.sourceInfo_[sourceIndex].bands;\n        samplesPerPixel[sourceIndex] = wantedSamples\n          ? wantedSamples.length\n          : image.getSamplesPerPixel();\n        const level = imageCount - (imageIndex + 1);\n\n        if (!sourceExtent) {\n          sourceExtent = getBoundingBox(image);\n        }\n\n        if (!sourceOrigin) {\n          sourceOrigin = getOrigin(image);\n        }\n\n        const imageResolutions = getResolutions(image, images[0]);\n        sourceResolutions[level] = imageResolutions[0];\n\n        const sourceTileSize = [image.getTileWidth(), image.getTileHeight()];\n\n        // request larger blocks for untiled layouts\n        if (\n          sourceTileSize[0] !== sourceTileSize[1] &&\n          sourceTileSize[1] < defaultTileSize\n        ) {\n          sourceTileSize[0] = defaultTileSize;\n          sourceTileSize[1] = defaultTileSize;\n        }\n\n        sourceTileSizes[level] = sourceTileSize;\n\n        const aspectRatio = imageResolutions[0] / Math.abs(imageResolutions[1]);\n        renderTileSizes[level] = [\n          sourceTileSize[0],\n          sourceTileSize[1] / aspectRatio,\n        ];\n      }\n\n      if (!extent) {\n        extent = sourceExtent;\n      } else {\n        getIntersection(extent, sourceExtent, extent);\n      }\n\n      if (!origin) {\n        origin = sourceOrigin;\n      } else {\n        const message = `Origin mismatch for source ${sourceIndex}, got [${sourceOrigin}] but expected [${origin}]`;\n        assertEqual(origin, sourceOrigin, 0, message, this.viewRejector);\n      }\n\n      if (!resolutions) {\n        resolutions = sourceResolutions;\n        this.resolutionFactors_[sourceIndex] = 1;\n      } else {\n        if (resolutions.length - minZoom > sourceResolutions.length) {\n          minZoom = resolutions.length - sourceResolutions.length;\n        }\n        const resolutionFactor =\n          resolutions[resolutions.length - 1] /\n          sourceResolutions[sourceResolutions.length - 1];\n        this.resolutionFactors_[sourceIndex] = resolutionFactor;\n        const scaledSourceResolutions = sourceResolutions.map(\n          (resolution) => (resolution *= resolutionFactor),\n        );\n        const message = `Resolution mismatch for source ${sourceIndex}, got [${scaledSourceResolutions}] but expected [${resolutions}]`;\n        assertEqual(\n          resolutions.slice(minZoom, resolutions.length),\n          scaledSourceResolutions,\n          0.02,\n          message,\n          this.viewRejector,\n        );\n      }\n\n      if (!commonRenderTileSizes) {\n        commonRenderTileSizes = renderTileSizes;\n      } else {\n        assertEqual(\n          commonRenderTileSizes.slice(minZoom, commonRenderTileSizes.length),\n          renderTileSizes,\n          0.01,\n          `Tile size mismatch for source ${sourceIndex}`,\n          this.viewRejector,\n        );\n      }\n\n      if (!commonSourceTileSizes) {\n        commonSourceTileSizes = sourceTileSizes;\n      } else {\n        assertEqual(\n          commonSourceTileSizes.slice(minZoom, commonSourceTileSizes.length),\n          sourceTileSizes,\n          0,\n          `Tile size mismatch for source ${sourceIndex}`,\n          this.viewRejector,\n        );\n      }\n\n      this.sourceImagery_[sourceIndex] = images.reverse();\n      this.sourceMasks_[sourceIndex] = masks.reverse();\n    }\n\n    for (let i = 0, ii = this.sourceImagery_.length; i < ii; ++i) {\n      const sourceImagery = this.sourceImagery_[i];\n      while (sourceImagery.length < resolutions.length) {\n        sourceImagery.unshift(undefined);\n      }\n    }\n\n    if (!this.getProjection()) {\n      this.determineProjection(sources);\n    }\n\n    this.samplesPerPixel_ = samplesPerPixel;\n    this.nodataValues_ = nodataValues;\n    this.metadata_ = metadata;\n\n    // decide if we need to add an alpha band to handle nodata\n    outer: for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      // option 1: source is configured with a nodata value\n      if (this.sourceInfo_[sourceIndex].nodata !== undefined) {\n        this.addAlpha_ = true;\n        break;\n      }\n      if (this.sourceMasks_[sourceIndex].length) {\n        this.addAlpha_ = true;\n        break;\n      }\n\n      const values = nodataValues[sourceIndex];\n\n      // option 2: check image metadata for limited bands\n      const bands = this.sourceInfo_[sourceIndex].bands;\n      if (bands) {\n        for (let i = 0; i < bands.length; ++i) {\n          if (values[bands[i] - 1] !== null) {\n            this.addAlpha_ = true;\n            break outer;\n          }\n        }\n        continue;\n      }\n\n      // option 3: check image metadata for all bands\n      for (let imageIndex = 0; imageIndex < values.length; ++imageIndex) {\n        if (values[imageIndex] !== null) {\n          this.addAlpha_ = true;\n          break outer;\n        }\n      }\n    }\n\n    let bandCount = this.addAlpha_ ? 1 : 0;\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      bandCount += samplesPerPixel[sourceIndex];\n    }\n    this.bandCount = bandCount;\n\n    const tileGrid = new TileGrid({\n      extent: extent,\n      minZoom: minZoom,\n      origin: origin,\n      resolutions: resolutions,\n      tileSizes: commonRenderTileSizes,\n    });\n\n    this.tileGrid = tileGrid;\n    this.setTileSizes(commonSourceTileSizes);\n\n    this.setLoader(this.loadTile_.bind(this));\n    this.setState('ready');\n\n    const zoom = 1;\n    if (resolutions.length === 2) {\n      resolutions = [resolutions[0], resolutions[1], resolutions[1] / 2];\n    } else if (resolutions.length === 1) {\n      resolutions = [resolutions[0] * 2, resolutions[0], resolutions[0] / 2];\n    }\n\n    this.viewResolver({\n      showFullExtent: true,\n      projection: this.projection,\n      resolutions: resolutions,\n      center: toUserCoordinate(getCenter(extent), this.projection),\n      extent: toUserExtent(extent, this.projection),\n      zoom: zoom,\n    });\n  }\n\n  /**\n   * @param {number} z The z tile index.\n   * @param {number} x The x tile index.\n   * @param {number} y The y tile index.\n   * @param {import('./DataTile.js').LoaderOptions} options The loader options.\n   * @return {Promise} The composed tile data.\n   * @private\n   */\n  loadTile_(z, x, y, options) {\n    const sourceTileSize = this.getTileSize(z);\n    const sourceCount = this.sourceImagery_.length;\n    const requests = new Array(sourceCount * 2);\n    const nodataValues = this.nodataValues_;\n    const sourceInfo = this.sourceInfo_;\n    const pool = getWorkerPool();\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      const source = sourceInfo[sourceIndex];\n      const resolutionFactor = this.resolutionFactors_[sourceIndex];\n      const pixelBounds = [\n        Math.round(x * (sourceTileSize[0] * resolutionFactor)),\n        Math.round(y * (sourceTileSize[1] * resolutionFactor)),\n        Math.round((x + 1) * (sourceTileSize[0] * resolutionFactor)),\n        Math.round((y + 1) * (sourceTileSize[1] * resolutionFactor)),\n      ];\n      const image = this.sourceImagery_[sourceIndex][z];\n      let samples;\n      if (source.bands) {\n        samples = source.bands.map(function (bandNumber) {\n          return bandNumber - 1;\n        });\n      }\n\n      /** @type {number|Array<number>} */\n      let fillValue;\n      if ('nodata' in source && source.nodata !== null) {\n        fillValue = source.nodata;\n      } else {\n        if (!samples) {\n          fillValue = nodataValues[sourceIndex];\n        } else {\n          fillValue = samples.map(function (sampleIndex) {\n            return nodataValues[sourceIndex][sampleIndex];\n          });\n        }\n      }\n\n      const readOptions = {\n        window: pixelBounds,\n        width: sourceTileSize[0],\n        height: sourceTileSize[1],\n        samples: samples,\n        fillValue: fillValue,\n        pool: pool,\n        interleave: false,\n        signal: options.signal,\n      };\n      if (readRGB(this.convertToRGB_, image)) {\n        requests[sourceIndex] = image.readRGB(readOptions);\n      } else {\n        requests[sourceIndex] = image.readRasters(readOptions);\n      }\n\n      // requests after `sourceCount` are for mask data (if any)\n      const maskIndex = sourceCount + sourceIndex;\n      const mask = this.sourceMasks_[sourceIndex][z];\n      if (!mask) {\n        requests[maskIndex] = Promise.resolve(null);\n        continue;\n      }\n\n      requests[maskIndex] = mask.readRasters({\n        window: pixelBounds,\n        width: sourceTileSize[0],\n        height: sourceTileSize[1],\n        samples: [0],\n        pool: pool,\n        interleave: false,\n      });\n    }\n\n    return Promise.all(requests)\n      .then(this.composeTile_.bind(this, sourceTileSize))\n      .catch(function (error) {\n        logError(error);\n        throw error;\n      });\n  }\n\n  /**\n   * @param {import(\"../size.js\").Size} sourceTileSize The source tile size.\n   * @param {Array} sourceSamples The source samples.\n   * @return {import(\"../DataTile.js\").Data} The composed tile data.\n   * @private\n   */\n  composeTile_(sourceTileSize, sourceSamples) {\n    const metadata = this.metadata_;\n    const sourceInfo = this.sourceInfo_;\n    const sourceCount = this.sourceImagery_.length;\n    const bandCount = this.bandCount;\n    const samplesPerPixel = this.samplesPerPixel_;\n    const nodataValues = this.nodataValues_;\n    const normalize = this.normalize_;\n    const addAlpha = this.addAlpha_;\n\n    const pixelCount = sourceTileSize[0] * sourceTileSize[1];\n    const dataLength = pixelCount * bandCount;\n\n    /** @type {Uint8Array|Float32Array} */\n    let data;\n    if (normalize) {\n      data = new Uint8Array(dataLength);\n    } else {\n      data = new Float32Array(dataLength);\n    }\n\n    let dataIndex = 0;\n    for (let pixelIndex = 0; pixelIndex < pixelCount; ++pixelIndex) {\n      let transparent = addAlpha;\n      for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n        const source = sourceInfo[sourceIndex];\n\n        let min = source.min;\n        let max = source.max;\n        let gain, bias;\n        if (normalize) {\n          const stats = metadata[sourceIndex][0];\n          if (min === undefined) {\n            if (stats && STATISTICS_MINIMUM in stats) {\n              min = parseFloat(stats[STATISTICS_MINIMUM]);\n            } else {\n              min = getMinForDataType(sourceSamples[sourceIndex][0]);\n            }\n          }\n          if (max === undefined) {\n            if (stats && STATISTICS_MAXIMUM in stats) {\n              max = parseFloat(stats[STATISTICS_MAXIMUM]);\n            } else {\n              max = getMaxForDataType(sourceSamples[sourceIndex][0]);\n            }\n          }\n\n          gain = 255 / (max - min);\n          bias = -min * gain;\n        }\n\n        for (\n          let sampleIndex = 0;\n          sampleIndex < samplesPerPixel[sourceIndex];\n          ++sampleIndex\n        ) {\n          const sourceValue =\n            sourceSamples[sourceIndex][sampleIndex][pixelIndex];\n\n          let value;\n          if (normalize) {\n            value = clamp(gain * sourceValue + bias, 0, 255);\n          } else {\n            value = sourceValue;\n          }\n\n          if (!addAlpha) {\n            data[dataIndex] = value;\n          } else {\n            let nodata = source.nodata;\n            if (nodata === undefined) {\n              let bandIndex;\n              if (source.bands) {\n                bandIndex = source.bands[sampleIndex] - 1;\n              } else {\n                bandIndex = sampleIndex;\n              }\n              nodata = nodataValues[sourceIndex][bandIndex];\n            }\n\n            const nodataIsNaN = isNaN(nodata);\n            if (\n              (!nodataIsNaN && sourceValue !== nodata) ||\n              (nodataIsNaN && !isNaN(sourceValue))\n            ) {\n              transparent = false;\n              data[dataIndex] = value;\n            }\n          }\n          dataIndex++;\n        }\n        if (!transparent) {\n          const maskIndex = sourceCount + sourceIndex;\n          const mask = sourceSamples[maskIndex];\n          if (mask && !mask[0][pixelIndex]) {\n            transparent = true;\n          }\n        }\n      }\n      if (addAlpha) {\n        if (!transparent) {\n          data[dataIndex] = 255;\n        }\n        dataIndex++;\n      }\n    }\n\n    return data;\n  }\n}\n\n/**\n * Get a promise for view properties based on the source.  Use the result of this function\n * as the `view` option in a map constructor.\n *\n *     const source = new GeoTIFF(options);\n *\n *     const map = new Map({\n *       target: 'map',\n *       layers: [\n *         new TileLayer({\n *           source: source,\n *         }),\n *       ],\n *       view: source.getView(),\n *     });\n *\n * @function\n * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\n * @api\n *\n */\nGeoTIFFSource.prototype.getView;\n\nexport default GeoTIFFSource;\n", "/**\n * @module ol/source/Google\n */\n\nimport TileImage from './TileImage.js';\nimport ViewHint from '../ViewHint.js';\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\nimport {getBottomLeft, getTopRight} from '../extent.js';\nimport {toLonLat} from '../proj.js';\n\nconst createSessionUrl = 'https://tile.googleapis.com/v1/createSession';\nconst tileUrl = 'https://tile.googleapis.com/v1/2dtiles';\nconst attributionUrl = 'https://tile.googleapis.com/tile/v1/viewport';\nconst maxZoom = 22;\n\n/**\n * @typedef {Object} Options\n * @property {string} key Google Map Tiles API key. Get yours at https://developers.google.com/maps/documentation/tile/get-api-key.\n * @property {string} [mapType='roadmap'] The type of [base map](https://developers.google.com/maps/documentation/tile/session_tokens#required_fields).\n * @property {string} [language='en-US'] An [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag) for information displayed on the tiles.\n * @property {string} [region='US'] A [Common Locale Data Repository](https://cldr.unicode.org/) (CLDR) region identifier that represents the user location.\n * @property {string} [imageFormat] The image format used for the map tiles (e.g. `'jpeg'`, or `'png'`).\n * @property {string} [scale] Scale for map elements (`'scaleFactor1x'`, `'scaleFactor2x'`, or `'scaleFactor4x'`).\n * @property {boolean} [highDpi=false] Use high-resolution tiles.\n * @property {Array<string>} [layerTypes] The layer types added to the map (e.g. `'layerRoadmap'`, `'layerStreetview'`, or `'layerTraffic'`).\n * @property {boolean} [overlay=false] Display only the `layerTypes` and not the underlying `mapType` (only works if `layerTypes` is provided).\n * @property {Array<Object>} [styles] [Custom styles](https://developers.google.com/maps/documentation/tile/style-reference) applied to the map.\n * @property {boolean} [attributionsCollapsible=true] Allow the attributions to be collapsed.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {Array<string>} [apiOptions] An array of values specifying additional options to apply.\n * @property {boolean} [wrapX=true] Wrap the world horizontally.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @typedef {Object} SessionTokenRequest\n * @property {string} mapType The map type.\n * @property {string} language The language.\n * @property {string} region The region.\n * @property {string} [imageFormat] The image format.\n * @property {string} [scale] The scale.\n * @property {boolean} [highDpi] Use high resolution tiles.\n * @property {Array<string>} [layerTypes] The layer types.\n * @property {boolean} [overlay] The overlay.\n * @property {Array<Object>} [styles] The styles.\n * @property {Array<string>} [apiOptions] An array of values specifying additional options to apply.\n */\n\n/**\n * @typedef {Object} SessionTokenResponse\n * @property {string} session The session token.\n * @property {string} expiry The session token expiry (seconds since the epoch as a string).\n * @property {number} tileWidth The tile width.\n * @property {number} tileHeight The tile height.\n * @property {string} imageFormat The image format.\n */\n\n/**\n * @classdesc\n * A tile layer source that renders tiles from the Google [Map Tiles API](https://developers.google.com/maps/documentation/tile/overview).\n * The constructor takes options that are passed to the request to create a session token.  Refer to the\n * [documentation](https://developers.google.com/maps/documentation/tile/session_tokens#required_fields)\n * for additional details.\n * @api\n */\nclass Google extends TileImage {\n  /**\n   * @param {Options} options Google Maps options.\n   */\n  constructor(options) {\n    const highDpi = !!options.highDpi;\n\n    super({\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      crossOrigin: 'anonymous',\n      interpolate: options.interpolate,\n      projection: 'EPSG:3857',\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      state: 'loading',\n      tileLoadFunction: options.tileLoadFunction,\n      tilePixelRatio: highDpi ? 2 : 1,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      transition: options.transition,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.apiKey_ = options.key;\n\n    /**\n     * @type {Error|null}\n     * @private\n     */\n    this.error_ = null;\n\n    /**\n     * @type {SessionTokenRequest}\n     */\n    const sessionTokenRequest = {\n      mapType: options.mapType || 'roadmap',\n      language: options.language || 'en-US',\n      region: options.region || 'US',\n    };\n    if (options.imageFormat) {\n      sessionTokenRequest.imageFormat = options.imageFormat;\n    }\n    if (options.scale) {\n      sessionTokenRequest.scale = options.scale;\n    }\n    if (highDpi) {\n      sessionTokenRequest.highDpi = true;\n    }\n    if (options.layerTypes) {\n      sessionTokenRequest.layerTypes = options.layerTypes;\n    }\n    if (options.styles) {\n      sessionTokenRequest.styles = options.styles;\n    }\n    if (options.overlay === true) {\n      sessionTokenRequest.overlay = true;\n    }\n    if (options.apiOptions) {\n      sessionTokenRequest.apiOptions = options.apiOptions;\n    }\n\n    /**\n     * @type {SessionTokenRequest}\n     * @private\n     */\n    this.sessionTokenRequest_ = sessionTokenRequest;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.sessionTokenValue_;\n\n    /**\n     * @type {ReturnType<typeof setTimeout>}\n     * @private\n     */\n    this.sessionRefreshId_;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.previousViewportAttribution_;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.previousViewportExtent_;\n\n    this.createSession_();\n  }\n\n  /**\n   * @return {Error|null} A source loading error. When the source state is `error`, use this function\n   * to get more information about the error. To debug a faulty configuration, you may want to use\n   * a listener like\n   * ```js\n   * source.on('change', () => {\n   *   if (source.getState() === 'error') {\n   *     console.error(source.getError());\n   *   }\n   * });\n   * ```\n   */\n  getError() {\n    return this.error_;\n  }\n\n  /**\n   * Exposed here so it can be overridden in the tests.\n   * @param {string} url The URL.\n   * @param {RequestInit} config The config.\n   * @return {Promise<Response>} A promise that resolves with the response.\n   */\n  fetchSessionToken(url, config) {\n    return fetch(url, config);\n  }\n\n  /**\n   * Get or renew a session token for use with tile requests.\n   * @private\n   */\n  async createSession_() {\n    const url = createSessionUrl + '?key=' + this.apiKey_;\n    const config = {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(this.sessionTokenRequest_),\n    };\n\n    const response = await this.fetchSessionToken(url, config);\n    if (!response.ok) {\n      try {\n        const body = await response.json();\n        this.error_ = new Error(body.error.message);\n      } catch {\n        this.error_ = new Error('Error fetching session token');\n      }\n      this.setState('error');\n      return;\n    }\n\n    /**\n     * @type {SessionTokenResponse}\n     */\n    const sessionTokenResponse = await response.json();\n\n    const tilePixelRatio = this.getTilePixelRatio(1);\n    const tileSize = [\n      sessionTokenResponse.tileWidth / tilePixelRatio,\n      sessionTokenResponse.tileHeight / tilePixelRatio,\n    ];\n\n    this.tileGrid = createXYZ({\n      extent: extentFromProjection(this.getProjection()),\n      maxZoom: maxZoom,\n      tileSize: tileSize,\n    });\n\n    const session = sessionTokenResponse.session;\n    this.sessionTokenValue_ = session;\n    const key = this.apiKey_;\n    this.tileUrlFunction = function (tileCoord, pixelRatio, projection) {\n      const z = tileCoord[0];\n      const x = tileCoord[1];\n      const y = tileCoord[2];\n      const url = `${tileUrl}/${z}/${x}/${y}?session=${session}&key=${key}`;\n      return url;\n    };\n\n    const expiry = parseInt(sessionTokenResponse.expiry, 10) * 1000;\n    const timeout = Math.max(expiry - Date.now() - 60 * 1000, 1);\n    this.sessionRefreshId_ = setTimeout(() => this.createSession_(), timeout);\n\n    this.setAttributions(this.fetchAttributions_.bind(this));\n    // even if the state is already ready, we want the change event\n    this.setState('ready');\n  }\n\n  /**\n   * @param {import('../Map.js').FrameState} frameState The frame state.\n   * @return {Promise<string>} The attributions.\n   * @private\n   */\n  async fetchAttributions_(frameState) {\n    if (\n      frameState.viewHints[ViewHint.ANIMATING] ||\n      frameState.viewHints[ViewHint.INTERACTING] ||\n      frameState.animate\n    ) {\n      return this.previousViewportAttribution_;\n    }\n    const [west, south] = toLonLat(\n      getBottomLeft(frameState.extent),\n      frameState.viewState.projection,\n    );\n    const [east, north] = toLonLat(\n      getTopRight(frameState.extent),\n      frameState.viewState.projection,\n    );\n    const tileGrid = this.getTileGrid();\n    const zoom = tileGrid.getZForResolution(\n      frameState.viewState.resolution,\n      this.zDirection,\n    );\n    const viewportExtent = `zoom=${zoom}&north=${north}&south=${south}&east=${east}&west=${west}`;\n    // check if the extent or zoom has actually changed to avoid unnecessary requests\n    if (this.previousViewportExtent_ == viewportExtent) {\n      return this.previousViewportAttribution_;\n    }\n    this.previousViewportExtent_ = viewportExtent;\n    const session = this.sessionTokenValue_;\n    const key = this.apiKey_;\n    const url = `${attributionUrl}?session=${session}&key=${key}&${viewportExtent}`;\n    this.previousViewportAttribution_ = await fetch(url)\n      .then((response) => response.json())\n      .then((json) => json.copyright);\n\n    return this.previousViewportAttribution_;\n  }\n\n  /**\n   * @override\n   */\n  disposeInternal() {\n    clearTimeout(this.sessionRefreshId_);\n    super.disposeInternal();\n  }\n}\n\nexport default Google;\n", "/**\n * @module ol/source/Zoomify\n */\nimport {DEFAULT_TILE_SIZE} from '../tilegrid/common.js';\n\nimport ImageTile from '../ImageTile.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport TileImage from './TileImage.js';\nimport TileState from '../TileState.js';\nimport {createCanvasContext2D} from '../dom.js';\nimport {createFromTileUrlFunctions} from '../tileurlfunction.js';\nimport {expandUrl} from '../uri.js';\nimport {getCenter} from '../extent.js';\nimport {toSize} from '../size.js';\n\n/**\n * @typedef {'default' | 'truncated'} TierSizeCalculation\n */\n\nexport class CustomTile extends ImageTile {\n  /**\n   * @param {import(\"../size.js\").Size} tileSize Full tile size.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {import(\"../Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @param {import(\"../Tile.js\").Options} [options] Tile options.\n   */\n  constructor(\n    tileSize,\n    tileCoord,\n    state,\n    src,\n    crossOrigin,\n    tileLoadFunction,\n    options,\n  ) {\n    super(tileCoord, state, src, crossOrigin, tileLoadFunction, options);\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement}\n     */\n    this.zoomifyImage_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.tileSize_ = tileSize;\n  }\n\n  /**\n   * Get the image element for this tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @override\n   */\n  getImage() {\n    if (this.zoomifyImage_) {\n      return this.zoomifyImage_;\n    }\n    const image = super.getImage();\n    if (this.state == TileState.LOADED) {\n      const tileSize = this.tileSize_;\n      if (image.width == tileSize[0] && image.height == tileSize[1]) {\n        this.zoomifyImage_ = image;\n        return image;\n      }\n      const context = createCanvasContext2D(tileSize[0], tileSize[1]);\n      context.drawImage(image, 0, 0);\n      this.zoomifyImage_ = context.canvas;\n      return context.canvas;\n    }\n    return image;\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value  you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {number} [tilePixelRatio] The pixel ratio used by the tile service. For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px by 512px images (for retina/hidpi devices) then `tilePixelRatio` should be set to `2`\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {string} url URL template or base URL of the Zoomify service.\n * A base URL is the fixed part\n * of the URL, excluding the tile group, z, x, and y folder structure, e.g.\n * `http://my.zoomify.info/IMAGE.TIF/`. A URL template must include\n * `{TileGroup}`, `{x}`, `{y}`, and `{z}` placeholders, e.g.\n * `http://my.zoomify.info/IMAGE.TIF/{TileGroup}/{z}-{x}-{y}.jpg`.\n * Internet Imaging Protocol (IIP) with JTL extension can be also used with\n * `{tileIndex}` and `{z}` placeholders, e.g.\n * `http://my.zoomify.info?FIF=IMAGE.TIF&JTL={z},{tileIndex}`.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {TierSizeCalculation} [tierSizeCalculation] Tier size calculation method: `default` or `truncated`.\n * @property {import(\"../size.js\").Size} size Size.\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the TileGrid that is created.\n * Default sets the TileGrid in the\n * fourth quadrant, meaning extent is `[0, -height, width, 0]`. To change the\n * extent to the first quadrant (the default for OpenLayers 2) set the extent\n * as `[0, 0, width, height]`.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {number} [tileSize=256] Tile size. Same tile size is used for all zoom levels.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Layer source for tile data in Zoomify format (both Zoomify and Internet\n * Imaging Protocol are supported).\n * @api\n */\nclass Zoomify extends TileImage {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    const size = options.size;\n    const tierSizeCalculation =\n      options.tierSizeCalculation !== undefined\n        ? options.tierSizeCalculation\n        : 'default';\n\n    const tilePixelRatio = options.tilePixelRatio || 1;\n    const imageWidth = size[0];\n    const imageHeight = size[1];\n    const tierSizeInTiles = [];\n    const tileSize = options.tileSize || DEFAULT_TILE_SIZE;\n    let tileSizeForTierSizeCalculation = tileSize * tilePixelRatio;\n\n    switch (tierSizeCalculation) {\n      case 'default':\n        while (\n          imageWidth > tileSizeForTierSizeCalculation ||\n          imageHeight > tileSizeForTierSizeCalculation\n        ) {\n          tierSizeInTiles.push([\n            Math.ceil(imageWidth / tileSizeForTierSizeCalculation),\n            Math.ceil(imageHeight / tileSizeForTierSizeCalculation),\n          ]);\n          tileSizeForTierSizeCalculation += tileSizeForTierSizeCalculation;\n        }\n        break;\n      case 'truncated':\n        let width = imageWidth;\n        let height = imageHeight;\n        while (\n          width > tileSizeForTierSizeCalculation ||\n          height > tileSizeForTierSizeCalculation\n        ) {\n          tierSizeInTiles.push([\n            Math.ceil(width / tileSizeForTierSizeCalculation),\n            Math.ceil(height / tileSizeForTierSizeCalculation),\n          ]);\n          width >>= 1;\n          height >>= 1;\n        }\n        break;\n      default:\n        throw new Error('Unknown `tierSizeCalculation` configured');\n    }\n\n    tierSizeInTiles.push([1, 1]);\n    tierSizeInTiles.reverse();\n\n    const resolutions = [tilePixelRatio];\n    const tileCountUpToTier = [0];\n    for (let i = 1, ii = tierSizeInTiles.length; i < ii; i++) {\n      resolutions.push(tilePixelRatio << i);\n      tileCountUpToTier.push(\n        tierSizeInTiles[i - 1][0] * tierSizeInTiles[i - 1][1] +\n          tileCountUpToTier[i - 1],\n      );\n    }\n    resolutions.reverse();\n\n    const tileGrid = new TileGrid({\n      tileSize: tileSize,\n      extent: options.extent || [0, -imageHeight, imageWidth, 0],\n      resolutions: resolutions,\n    });\n\n    let url = options.url;\n    if (url && !url.includes('{TileGroup}') && !url.includes('{tileIndex}')) {\n      url += '{TileGroup}/{z}-{x}-{y}.jpg';\n    }\n    const urls = expandUrl(url);\n\n    let tileWidth = tileSize * tilePixelRatio;\n\n    /**\n     * @param {string} template Template.\n     * @return {import(\"../Tile.js\").UrlFunction} Tile URL function.\n     */\n    function createFromTemplate(template) {\n      return (\n        /**\n         * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n         * @param {number} pixelRatio Pixel ratio.\n         * @param {import(\"../proj/Projection.js\").default} projection Projection.\n         * @return {string|undefined} Tile URL.\n         */\n        function (tileCoord, pixelRatio, projection) {\n          if (!tileCoord) {\n            return undefined;\n          }\n          const tileCoordZ = tileCoord[0];\n          const tileCoordX = tileCoord[1];\n          const tileCoordY = tileCoord[2];\n          const tileIndex =\n            tileCoordX + tileCoordY * tierSizeInTiles[tileCoordZ][0];\n          const tileGroup =\n            ((tileIndex + tileCountUpToTier[tileCoordZ]) / tileWidth) | 0;\n          const localContext = {\n            'z': tileCoordZ,\n            'x': tileCoordX,\n            'y': tileCoordY,\n            'tileIndex': tileIndex,\n            'TileGroup': 'TileGroup' + tileGroup,\n          };\n          return template.replace(/\\{(\\w+?)\\}/g, function (m, p) {\n            return localContext[p];\n          });\n        }\n      );\n    }\n\n    const tileUrlFunction = createFromTileUrlFunctions(\n      urls.map(createFromTemplate),\n    );\n\n    const ZoomifyTileClass = CustomTile.bind(\n      null,\n      toSize(tileSize * tilePixelRatio),\n    );\n\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      interpolate: options.interpolate,\n      projection: options.projection,\n      tilePixelRatio: tilePixelRatio,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileClass: ZoomifyTileClass,\n      tileGrid: tileGrid,\n      tileUrlFunction: tileUrlFunction,\n      transition: options.transition,\n    });\n\n    /**\n     * @type {number|import(\"../array.js\").NearestDirectionFunction}\n     */\n    this.zDirection = options.zDirection;\n\n    // Server retina tile detection (non-standard):\n    // Try loading the center tile for the highest resolution. If it is not\n    // available, we are dealing with retina tiles, and need to adjust the\n    // tile url calculation.\n    const tileUrl = tileGrid.getTileCoordForCoordAndResolution(\n      getCenter(tileGrid.getExtent()),\n      resolutions[resolutions.length - 1],\n    );\n    const testTileUrl = tileUrlFunction(tileUrl, 1, null);\n    const image = new Image();\n    image.addEventListener('error', () => {\n      tileWidth = tileSize;\n      this.changed();\n    });\n    image.src = testTileUrl;\n  }\n}\n\nexport default Zoomify;\n", "/**\n * @module ol/format/IIIFInfo\n */\n\nimport {assert} from '../asserts.js';\n\n/**\n * @typedef {Object} PreferredOptions\n * @property {string} [format] Preferred image format. Will be used if the image information\n * indicates support for that format.\n * @property {string} [quality] IIIF image qualitiy.  Will be used if the image information\n * indicates support for that quality.\n */\n\n/**\n * @typedef {Object} SupportedFeatures\n * @property {Array<string>} [supports] Supported IIIF image size and region\n * calculation features.\n * @property {Array<string>} [formats] Supported image formats.\n * @property {Array<string>} [qualities] Supported IIIF image qualities.\n */\n\n/**\n * @typedef {Object} TileInfo\n * @property {Array<number>} scaleFactors Supported resolution scaling factors.\n * @property {number} width Tile width in pixels.\n * @property {number} [height] Tile height in pixels. Same as tile width if height is\n * not given.\n */\n\n/**\n * @typedef {Object} IiifProfile\n * @property {Array<string>} [formats] Supported image formats for the image service.\n * @property {Array<string>} [qualities] Supported IIIF image qualities.\n * @property {Array<string>} [supports] Supported features.\n * @property {number} [maxArea] Maximum area (pixels) available for this image service.\n * @property {number} [maxHeight] Maximum height.\n * @property {number} [maxWidth] Maximum width.\n */\n\n/**\n * @typedef {Object<string,string|number|Array<number|string|IiifProfile|Object<string, number>|TileInfo>>}\n *    ImageInformationResponse\n */\n\n/**\n * Enum representing the major IIIF Image API versions\n * @enum {string}\n */\nexport const Versions = {\n  VERSION1: 'version1',\n  VERSION2: 'version2',\n  VERSION3: 'version3',\n};\n\n/**\n * Supported image formats, qualities and supported region / size calculation features\n * for different image API versions and compliance levels\n * @const\n * @type {Object<string, Object<string, SupportedFeatures>>}\n */\nconst IIIF_PROFILE_VALUES = {};\nIIIF_PROFILE_VALUES[Versions.VERSION1] = {\n  'level0': {\n    supports: [],\n    formats: [],\n    qualities: ['native'],\n  },\n  'level1': {\n    supports: ['regionByPx', 'sizeByW', 'sizeByH', 'sizeByPct'],\n    formats: ['jpg'],\n    qualities: ['native'],\n  },\n  'level2': {\n    supports: [\n      'regionByPx',\n      'regionByPct',\n      'sizeByW',\n      'sizeByH',\n      'sizeByPct',\n      'sizeByConfinedWh',\n      'sizeByWh',\n    ],\n    formats: ['jpg', 'png'],\n    qualities: ['native', 'color', 'grey', 'bitonal'],\n  },\n};\nIIIF_PROFILE_VALUES[Versions.VERSION2] = {\n  'level0': {\n    supports: [],\n    formats: ['jpg'],\n    qualities: ['default'],\n  },\n  'level1': {\n    supports: ['regionByPx', 'sizeByW', 'sizeByH', 'sizeByPct'],\n    formats: ['jpg'],\n    qualities: ['default'],\n  },\n  'level2': {\n    supports: [\n      'regionByPx',\n      'regionByPct',\n      'sizeByW',\n      'sizeByH',\n      'sizeByPct',\n      'sizeByConfinedWh',\n      'sizeByDistortedWh',\n      'sizeByWh',\n    ],\n    formats: ['jpg', 'png'],\n    qualities: ['default', 'bitonal'],\n  },\n};\nIIIF_PROFILE_VALUES[Versions.VERSION3] = {\n  'level0': {\n    supports: [],\n    formats: ['jpg'],\n    qualities: ['default'],\n  },\n  'level1': {\n    supports: ['regionByPx', 'regionSquare', 'sizeByW', 'sizeByH', 'sizeByWh'],\n    formats: ['jpg'],\n    qualities: ['default'],\n  },\n  'level2': {\n    supports: [\n      'regionByPx',\n      'regionSquare',\n      'regionByPct',\n      'sizeByW',\n      'sizeByH',\n      'sizeByPct',\n      'sizeByConfinedWh',\n      'sizeByWh',\n    ],\n    formats: ['jpg', 'png'],\n    qualities: ['default'],\n  },\n};\nIIIF_PROFILE_VALUES['none'] = {\n  'none': {\n    supports: [],\n    formats: [],\n    qualities: [],\n  },\n};\n\nconst COMPLIANCE_VERSION1 =\n  /^https?:\\/\\/library\\.stanford\\.edu\\/iiif\\/image-api\\/(?:1\\.1\\/)?compliance\\.html#level[0-2]$/;\nconst COMPLIANCE_VERSION2 =\n  /^https?:\\/\\/iiif\\.io\\/api\\/image\\/2\\/level[0-2](?:\\.json)?$/;\nconst COMPLIANCE_VERSION3 =\n  /(^https?:\\/\\/iiif\\.io\\/api\\/image\\/3\\/level[0-2](?:\\.json)?$)|(^level[0-2]$)/;\n\nfunction generateVersion1Options(iiifInfo) {\n  let levelProfile = iiifInfo.getComplianceLevelSupportedFeatures();\n  // Version 1.0 and 1.1 do not require a profile.\n  if (levelProfile === undefined) {\n    levelProfile = IIIF_PROFILE_VALUES[Versions.VERSION1]['level0'];\n  }\n  return {\n    url:\n      iiifInfo.imageInfo['@id'] === undefined\n        ? undefined\n        : iiifInfo.imageInfo['@id'].replace(/\\/?(?:info\\.json)?$/g, ''),\n    supports: levelProfile.supports,\n    formats: [\n      ...levelProfile.formats,\n      iiifInfo.imageInfo.formats === undefined\n        ? []\n        : iiifInfo.imageInfo.formats,\n    ],\n    qualities: [\n      ...levelProfile.qualities,\n      iiifInfo.imageInfo.qualities === undefined\n        ? []\n        : iiifInfo.imageInfo.qualities,\n    ],\n    resolutions: iiifInfo.imageInfo.scale_factors,\n    tileSize:\n      iiifInfo.imageInfo.tile_width !== undefined\n        ? iiifInfo.imageInfo.tile_height !== undefined\n          ? [iiifInfo.imageInfo.tile_width, iiifInfo.imageInfo.tile_height]\n          : [iiifInfo.imageInfo.tile_width, iiifInfo.imageInfo.tile_width]\n        : iiifInfo.imageInfo.tile_height != undefined\n          ? [iiifInfo.imageInfo.tile_height, iiifInfo.imageInfo.tile_height]\n          : undefined,\n  };\n}\n\nfunction generateVersion2Options(iiifInfo) {\n  const levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(),\n    additionalProfile =\n      Array.isArray(iiifInfo.imageInfo.profile) &&\n      iiifInfo.imageInfo.profile.length > 1,\n    profileSupports =\n      additionalProfile && iiifInfo.imageInfo.profile[1].supports\n        ? iiifInfo.imageInfo.profile[1].supports\n        : [],\n    profileFormats =\n      additionalProfile && iiifInfo.imageInfo.profile[1].formats\n        ? iiifInfo.imageInfo.profile[1].formats\n        : [],\n    profileQualities =\n      additionalProfile && iiifInfo.imageInfo.profile[1].qualities\n        ? iiifInfo.imageInfo.profile[1].qualities\n        : [];\n  return {\n    url: iiifInfo.imageInfo['@id'].replace(/\\/?(?:info\\.json)?$/g, ''),\n    sizes:\n      iiifInfo.imageInfo.sizes === undefined\n        ? undefined\n        : iiifInfo.imageInfo.sizes.map(function (size) {\n            return [size.width, size.height];\n          }),\n    tileSize:\n      iiifInfo.imageInfo.tiles === undefined\n        ? undefined\n        : [\n            iiifInfo.imageInfo.tiles.map(function (tile) {\n              return tile.width;\n            })[0],\n            iiifInfo.imageInfo.tiles.map(function (tile) {\n              return tile.height === undefined ? tile.width : tile.height;\n            })[0],\n          ],\n    resolutions:\n      iiifInfo.imageInfo.tiles === undefined\n        ? undefined\n        : iiifInfo.imageInfo.tiles.map(function (tile) {\n            return tile.scaleFactors;\n          })[0],\n    supports: [...levelProfile.supports, ...profileSupports],\n    formats: [...levelProfile.formats, ...profileFormats],\n    qualities: [...levelProfile.qualities, ...profileQualities],\n  };\n}\n\nfunction generateVersion3Options(iiifInfo) {\n  const levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(),\n    formats =\n      iiifInfo.imageInfo.extraFormats === undefined\n        ? levelProfile.formats\n        : [...levelProfile.formats, ...iiifInfo.imageInfo.extraFormats],\n    preferredFormat =\n      iiifInfo.imageInfo.preferredFormats !== undefined &&\n      Array.isArray(iiifInfo.imageInfo.preferredFormats) &&\n      iiifInfo.imageInfo.preferredFormats.length > 0\n        ? iiifInfo.imageInfo.preferredFormats\n            .filter(function (format) {\n              return ['jpg', 'png', 'gif'].includes(format);\n            })\n            .reduce(function (acc, format) {\n              return acc === undefined && formats.includes(format)\n                ? format\n                : acc;\n            }, undefined)\n        : undefined;\n  return {\n    url: iiifInfo.imageInfo['id'],\n    sizes:\n      iiifInfo.imageInfo.sizes === undefined\n        ? undefined\n        : iiifInfo.imageInfo.sizes.map(function (size) {\n            return [size.width, size.height];\n          }),\n    tileSize:\n      iiifInfo.imageInfo.tiles === undefined\n        ? undefined\n        : [\n            iiifInfo.imageInfo.tiles.map(function (tile) {\n              return tile.width;\n            })[0],\n            iiifInfo.imageInfo.tiles.map(function (tile) {\n              return tile.height;\n            })[0],\n          ],\n    resolutions:\n      iiifInfo.imageInfo.tiles === undefined\n        ? undefined\n        : iiifInfo.imageInfo.tiles.map(function (tile) {\n            return tile.scaleFactors;\n          })[0],\n    supports:\n      iiifInfo.imageInfo.extraFeatures === undefined\n        ? levelProfile.supports\n        : [...levelProfile.supports, ...iiifInfo.imageInfo.extraFeatures],\n    formats: formats,\n    qualities:\n      iiifInfo.imageInfo.extraQualities === undefined\n        ? levelProfile.qualities\n        : [...levelProfile.qualities, ...iiifInfo.imageInfo.extraQualities],\n    preferredFormat: preferredFormat,\n  };\n}\n\nconst versionFunctions = {};\nversionFunctions[Versions.VERSION1] = generateVersion1Options;\nversionFunctions[Versions.VERSION2] = generateVersion2Options;\nversionFunctions[Versions.VERSION3] = generateVersion3Options;\n\n/**\n * @classdesc\n * Format for transforming IIIF Image API image information responses into\n * IIIF tile source ready options\n *\n * @api\n */\nclass IIIFInfo {\n  /**\n   * @param {string|ImageInformationResponse} imageInfo\n   * Deserialized image information JSON response object or JSON response as string\n   */\n  constructor(imageInfo) {\n    this.setImageInfo(imageInfo);\n  }\n\n  /**\n   * @param {string|ImageInformationResponse} imageInfo\n   * Deserialized image information JSON response object or JSON response as string\n   * @api\n   */\n  setImageInfo(imageInfo) {\n    if (typeof imageInfo == 'string') {\n      this.imageInfo = JSON.parse(imageInfo);\n    } else {\n      this.imageInfo = imageInfo;\n    }\n  }\n\n  /**\n   * @return {Versions|undefined} Major IIIF version.\n   * @api\n   */\n  getImageApiVersion() {\n    if (this.imageInfo === undefined) {\n      return undefined;\n    }\n    let context = this.imageInfo['@context'] || 'ol-no-context';\n    if (typeof context == 'string') {\n      context = [context];\n    }\n    for (let i = 0; i < context.length; i++) {\n      switch (context[i]) {\n        case 'http://library.stanford.edu/iiif/image-api/1.1/context.json':\n        case 'http://iiif.io/api/image/1/context.json':\n          return Versions.VERSION1;\n        case 'http://iiif.io/api/image/2/context.json':\n          return Versions.VERSION2;\n        case 'http://iiif.io/api/image/3/context.json':\n          return Versions.VERSION3;\n        case 'ol-no-context':\n          // Image API 1.0 has no '@context'\n          if (\n            this.getComplianceLevelEntryFromProfile(Versions.VERSION1) &&\n            this.imageInfo.identifier\n          ) {\n            return Versions.VERSION1;\n          }\n          break;\n        default:\n      }\n    }\n    assert(\n      false,\n      'Cannot determine IIIF Image API version from provided image information JSON',\n    );\n  }\n\n  /**\n   * @param {Versions} version Optional IIIF image API version\n   * @return {string|undefined} Compliance level as it appears in the IIIF image information\n   * response.\n   */\n  getComplianceLevelEntryFromProfile(version) {\n    if (this.imageInfo === undefined || this.imageInfo.profile === undefined) {\n      return undefined;\n    }\n    if (version === undefined) {\n      version = this.getImageApiVersion();\n    }\n    switch (version) {\n      case Versions.VERSION1:\n        if (COMPLIANCE_VERSION1.test(this.imageInfo.profile)) {\n          return this.imageInfo.profile;\n        }\n        break;\n      case Versions.VERSION3:\n        if (COMPLIANCE_VERSION3.test(this.imageInfo.profile)) {\n          return this.imageInfo.profile;\n        }\n        break;\n      case Versions.VERSION2:\n        if (\n          typeof this.imageInfo.profile === 'string' &&\n          COMPLIANCE_VERSION2.test(this.imageInfo.profile)\n        ) {\n          return this.imageInfo.profile;\n        }\n        if (\n          Array.isArray(this.imageInfo.profile) &&\n          this.imageInfo.profile.length > 0 &&\n          typeof this.imageInfo.profile[0] === 'string' &&\n          COMPLIANCE_VERSION2.test(this.imageInfo.profile[0])\n        ) {\n          return this.imageInfo.profile[0];\n        }\n        break;\n      default:\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Versions} version Optional IIIF image API version\n   * @return {string} Compliance level, on of 'level0', 'level1' or 'level2' or undefined\n   */\n  getComplianceLevelFromProfile(version) {\n    const complianceLevel = this.getComplianceLevelEntryFromProfile(version);\n    if (complianceLevel === undefined) {\n      return undefined;\n    }\n    const level = complianceLevel.match(/level[0-2](?:\\.json)?$/g);\n    return Array.isArray(level) ? level[0].replace('.json', '') : undefined;\n  }\n\n  /**\n   * @return {SupportedFeatures|undefined} Image formats, qualities and region / size calculation\n   * methods that are supported by the IIIF service.\n   */\n  getComplianceLevelSupportedFeatures() {\n    if (this.imageInfo === undefined) {\n      return undefined;\n    }\n    const version = this.getImageApiVersion();\n    const level = this.getComplianceLevelFromProfile(version);\n    if (level === undefined) {\n      return IIIF_PROFILE_VALUES['none']['none'];\n    }\n    return IIIF_PROFILE_VALUES[version][level];\n  }\n\n  /**\n   * @param {PreferredOptions} [preferredOptions] Optional options for preferred format and quality.\n   * @return {import(\"../source/IIIF.js\").Options|undefined} IIIF tile source ready constructor options.\n   * @api\n   */\n  getTileSourceOptions(preferredOptions) {\n    const options = preferredOptions || {},\n      version = this.getImageApiVersion();\n    if (version === undefined) {\n      return undefined;\n    }\n    const imageOptions =\n      version === undefined ? undefined : versionFunctions[version](this);\n    if (imageOptions === undefined) {\n      return undefined;\n    }\n    return {\n      url: imageOptions.url,\n      version: version,\n      size: [this.imageInfo.width, this.imageInfo.height],\n      sizes: imageOptions.sizes,\n      format:\n        options.format !== undefined &&\n        imageOptions.formats.includes(options.format)\n          ? options.format\n          : imageOptions.preferredFormat !== undefined\n            ? imageOptions.preferredFormat\n            : 'jpg',\n      supports: imageOptions.supports,\n      quality:\n        options.quality && imageOptions.qualities.includes(options.quality)\n          ? options.quality\n          : imageOptions.qualities.includes('native')\n            ? 'native'\n            : 'default',\n      resolutions: Array.isArray(imageOptions.resolutions)\n        ? imageOptions.resolutions.sort(function (a, b) {\n            return b - a;\n          })\n        : undefined,\n      tileSize: imageOptions.tileSize,\n    };\n  }\n}\n\nexport default IIIFInfo;\n", "/**\n * @module ol/source/IIIF\n */\n\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport TileImage from './TileImage.js';\nimport {CustomTile} from './Zoomify.js';\nimport {DEFAULT_TILE_SIZE} from '../tilegrid/common.js';\nimport {Versions} from '../format/IIIFInfo.js';\nimport {assert} from '../asserts.js';\nimport {getTopLeft} from '../extent.js';\nimport {toSize} from '../size.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\n * @property {null|string} [crossOrigin] The value for the crossOrigin option of the request.\n * @property {import(\"../extent.js\").Extent} [extent=[0, -height, width, 0]] The extent.\n * @property {string} [format='jpg'] Requested image format.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {string} [quality] Requested IIIF image quality. Default is 'native'\n * for version 1, 'default' for versions 2 and 3.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {Array<number>} [resolutions] Supported resolutions as given in IIIF 'scaleFactors'\n * @property {import(\"../size.js\").Size} size Size of the image [width, height].\n * @property {Array<import(\"../size.js\").Size>} [sizes] Supported scaled image sizes.\n * Content of the IIIF info.json 'sizes' property, but as array of Size objects.\n * @property {import(\"./Source.js\").State} [state] Source state.\n * @property {Array<string>} [supports=[]] Supported IIIF region and size calculation\n * features.\n * @property {number} [tilePixelRatio] Tile pixel ratio.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * Same tile size is used for all zoom levels. If tile size is a number,\n * a square tile is assumed. If the IIIF image service supports arbitrary\n * tiling (sizeByH, sizeByW, sizeByWh or sizeByPct as well as regionByPx or regionByPct\n * are supported), the default tilesize is 256.\n * @property {number} [transition] Transition.\n * @property {string} [url] Base URL of the IIIF Image service.\n * This should be the same as the IIIF Image ID.\n * @property {import(\"../format/IIIFInfo.js\").Versions} [version=Versions.VERSION2] Service's IIIF Image API version.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\nfunction formatPercentage(percentage) {\n  return percentage.toLocaleString('en', {maximumFractionDigits: 10});\n}\n\n/**\n * @classdesc\n * Layer source for IIIF Image API services.\n * @api\n */\nclass IIIF extends TileImage {\n  /**\n   * @param {Options} [options] Tile source options. Use {@link import(\"../format/IIIFInfo.js\").IIIFInfo}\n   * to parse Image API service information responses into constructor options.\n   * @api\n   */\n  constructor(options) {\n    /**\n     * @type {Partial<Options>}\n     */\n    const partialOptions = options || {};\n\n    let baseUrl = partialOptions.url || '';\n    baseUrl =\n      baseUrl +\n      (baseUrl.lastIndexOf('/') === baseUrl.length - 1 || baseUrl === ''\n        ? ''\n        : '/');\n    const version = partialOptions.version || Versions.VERSION2;\n    const sizes = partialOptions.sizes || [];\n    const size = partialOptions.size;\n    assert(\n      size != undefined &&\n        Array.isArray(size) &&\n        size.length == 2 &&\n        !isNaN(size[0]) &&\n        size[0] > 0 &&\n        !isNaN(size[1]) &&\n        size[1] > 0,\n      'Missing or invalid `size`',\n    );\n    const width = size[0];\n    const height = size[1];\n    const tileSize = partialOptions.tileSize;\n    const tilePixelRatio = partialOptions.tilePixelRatio || 1;\n    const format = partialOptions.format || 'jpg';\n    const quality =\n      partialOptions.quality ||\n      (partialOptions.version == Versions.VERSION1 ? 'native' : 'default');\n    let resolutions = partialOptions.resolutions || [];\n    const supports = partialOptions.supports || [];\n    const extent = partialOptions.extent || [0, -height, width, 0];\n\n    const supportsListedSizes =\n      sizes != undefined && Array.isArray(sizes) && sizes.length > 0;\n    const supportsListedTiles =\n      tileSize !== undefined &&\n      ((typeof tileSize === 'number' &&\n        Number.isInteger(tileSize) &&\n        tileSize > 0) ||\n        (Array.isArray(tileSize) && tileSize.length > 0));\n    const supportsArbitraryTiling =\n      supports != undefined &&\n      Array.isArray(supports) &&\n      (supports.includes('regionByPx') || supports.includes('regionByPct')) &&\n      (supports.includes('sizeByWh') ||\n        supports.includes('sizeByH') ||\n        supports.includes('sizeByW') ||\n        supports.includes('sizeByPct'));\n\n    let tileWidth, tileHeight, maxZoom;\n\n    resolutions.sort(function (a, b) {\n      return b - a;\n    });\n\n    if (supportsListedTiles || supportsArbitraryTiling) {\n      if (tileSize != undefined) {\n        if (\n          typeof tileSize === 'number' &&\n          Number.isInteger(tileSize) &&\n          tileSize > 0\n        ) {\n          tileWidth = tileSize;\n          tileHeight = tileSize;\n        } else if (Array.isArray(tileSize) && tileSize.length > 0) {\n          if (\n            tileSize.length == 1 ||\n            (tileSize[1] == undefined && Number.isInteger(tileSize[0]))\n          ) {\n            tileWidth = tileSize[0];\n            tileHeight = tileSize[0];\n          }\n          if (tileSize.length == 2) {\n            if (\n              Number.isInteger(tileSize[0]) &&\n              Number.isInteger(tileSize[1])\n            ) {\n              tileWidth = tileSize[0];\n              tileHeight = tileSize[1];\n            } else if (\n              tileSize[0] == undefined &&\n              Number.isInteger(tileSize[1])\n            ) {\n              tileWidth = tileSize[1];\n              tileHeight = tileSize[1];\n            }\n          }\n        }\n      }\n      if (tileWidth === undefined || tileHeight === undefined) {\n        tileWidth = DEFAULT_TILE_SIZE;\n        tileHeight = DEFAULT_TILE_SIZE;\n      }\n      if (resolutions.length == 0) {\n        maxZoom = Math.max(\n          Math.ceil(Math.log(width / tileWidth) / Math.LN2),\n          Math.ceil(Math.log(height / tileHeight) / Math.LN2),\n        );\n        for (let i = maxZoom; i >= 0; i--) {\n          resolutions.push(Math.pow(2, i));\n        }\n      } else {\n        const maxScaleFactor = Math.max(...resolutions);\n        // TODO maxScaleFactor might not be a power to 2\n        maxZoom = Math.round(Math.log(maxScaleFactor) / Math.LN2);\n      }\n    } else {\n      // No tile support.\n      tileWidth = width;\n      tileHeight = height;\n      resolutions = [];\n      if (supportsListedSizes) {\n        /*\n         * 'sizes' provided. Use full region in different resolutions. Every\n         * resolution has only one tile.\n         */\n        sizes.sort(function (a, b) {\n          return a[0] - b[0];\n        });\n        maxZoom = -1;\n        const ignoredSizesIndex = [];\n        for (let i = 0; i < sizes.length; i++) {\n          const resolution = width / sizes[i][0];\n          if (\n            resolutions.length > 0 &&\n            resolutions[resolutions.length - 1] == resolution\n          ) {\n            ignoredSizesIndex.push(i);\n            continue;\n          }\n          resolutions.push(resolution);\n          maxZoom++;\n        }\n        if (ignoredSizesIndex.length > 0) {\n          for (let i = 0; i < ignoredSizesIndex.length; i++) {\n            sizes.splice(ignoredSizesIndex[i] - i, 1);\n          }\n        }\n      } else {\n        // No useful image information at all. Try pseudo tile with full image.\n        resolutions.push(1);\n        sizes.push([width, height]);\n        maxZoom = 0;\n      }\n    }\n\n    const tileGrid = new TileGrid({\n      tileSize: [tileWidth, tileHeight],\n      extent: extent,\n      origin: getTopLeft(extent),\n      resolutions: resolutions,\n    });\n\n    const tileUrlFunction = function (tileCoord, pixelRatio, projection) {\n      let regionParam, sizeParam;\n      const zoom = tileCoord[0];\n      if (zoom > maxZoom) {\n        return;\n      }\n      const tileX = tileCoord[1],\n        tileY = tileCoord[2],\n        scale = resolutions[zoom];\n      if (\n        tileX === undefined ||\n        tileY === undefined ||\n        scale === undefined ||\n        tileX < 0 ||\n        Math.ceil(width / scale / tileWidth) <= tileX ||\n        tileY < 0 ||\n        Math.ceil(height / scale / tileHeight) <= tileY\n      ) {\n        return;\n      }\n      if (supportsArbitraryTiling || supportsListedTiles) {\n        const regionX = tileX * tileWidth * scale,\n          regionY = tileY * tileHeight * scale;\n        let regionW = tileWidth * scale,\n          regionH = tileHeight * scale,\n          sizeW = tileWidth,\n          sizeH = tileHeight;\n        if (regionX + regionW > width) {\n          regionW = width - regionX;\n        }\n        if (regionY + regionH > height) {\n          regionH = height - regionY;\n        }\n        if (regionX + tileWidth * scale > width) {\n          sizeW = Math.floor((width - regionX + scale - 1) / scale);\n        }\n        if (regionY + tileHeight * scale > height) {\n          sizeH = Math.floor((height - regionY + scale - 1) / scale);\n        }\n        if (\n          regionX == 0 &&\n          regionW == width &&\n          regionY == 0 &&\n          regionH == height\n        ) {\n          // canonical full image region parameter is 'full', not 'x,y,w,h'\n          regionParam = 'full';\n        } else if (\n          !supportsArbitraryTiling ||\n          supports.includes('regionByPx')\n        ) {\n          regionParam = regionX + ',' + regionY + ',' + regionW + ',' + regionH;\n        } else if (supports.includes('regionByPct')) {\n          const pctX = formatPercentage((regionX / width) * 100),\n            pctY = formatPercentage((regionY / height) * 100),\n            pctW = formatPercentage((regionW / width) * 100),\n            pctH = formatPercentage((regionH / height) * 100);\n          regionParam = 'pct:' + pctX + ',' + pctY + ',' + pctW + ',' + pctH;\n        }\n        if (\n          version == Versions.VERSION3 &&\n          (!supportsArbitraryTiling || supports.includes('sizeByWh'))\n        ) {\n          sizeParam = sizeW + ',' + sizeH;\n        } else if (!supportsArbitraryTiling || supports.includes('sizeByW')) {\n          sizeParam = sizeW + ',';\n        } else if (supports.includes('sizeByH')) {\n          sizeParam = ',' + sizeH;\n        } else if (supports.includes('sizeByWh')) {\n          sizeParam = sizeW + ',' + sizeH;\n        } else if (supports.includes('sizeByPct')) {\n          sizeParam = 'pct:' + formatPercentage(100 / scale);\n        }\n      } else {\n        regionParam = 'full';\n        if (supportsListedSizes) {\n          const regionWidth = sizes[zoom][0],\n            regionHeight = sizes[zoom][1];\n          if (version == Versions.VERSION3) {\n            if (regionWidth == width && regionHeight == height) {\n              sizeParam = 'max';\n            } else {\n              sizeParam = regionWidth + ',' + regionHeight;\n            }\n          } else {\n            if (regionWidth == width) {\n              sizeParam = 'full';\n            } else {\n              sizeParam = regionWidth + ',';\n            }\n          }\n        } else {\n          sizeParam = version == Versions.VERSION3 ? 'max' : 'full';\n        }\n      }\n      return (\n        baseUrl + regionParam + '/' + sizeParam + '/0/' + quality + '.' + format\n      );\n    };\n\n    const IiifTileClass = CustomTile.bind(\n      null,\n      toSize(tileSize || 256).map(function (size) {\n        return size * tilePixelRatio;\n      }),\n    );\n\n    super({\n      attributions: partialOptions.attributions,\n      attributionsCollapsible: partialOptions.attributionsCollapsible,\n      cacheSize: partialOptions.cacheSize,\n      crossOrigin: partialOptions.crossOrigin,\n      interpolate: partialOptions.interpolate,\n      projection: partialOptions.projection,\n      reprojectionErrorThreshold: partialOptions.reprojectionErrorThreshold,\n      state: partialOptions.state,\n      tileClass: IiifTileClass,\n      tileGrid: tileGrid,\n      tilePixelRatio: partialOptions.tilePixelRatio,\n      tileUrlFunction: tileUrlFunction,\n      transition: partialOptions.transition,\n    });\n\n    /**\n     * @type {number|import(\"../array.js\").NearestDirectionFunction}\n     */\n    this.zDirection = partialOptions.zDirection;\n  }\n}\n\nexport default IIIF;\n", "/**\n * @module ol/source/arcgisRest\n */\n\nimport {DECIMALS} from './common.js';\nimport {appendParams} from '../uri.js';\nimport {decode} from '../Image.js';\nimport {getHeight, getWidth} from '../extent.js';\nimport {get as getProjection} from '../proj.js';\nimport {getRequestExtent} from './Image.js';\nimport {round} from '../math.js';\n\n/**\n * @param {string} baseUrl Base URL for the ArcGIS Rest service.\n * @param {import(\"../extent.js\").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @param {import(\"../proj/Projection.js\").default} projection Projection.\n * @param {Object} params Params.\n * @return {string} Request URL.\n */\nexport function getRequestUrl(\n  baseUrl,\n  extent,\n  resolution,\n  pixelRatio,\n  projection,\n  params,\n) {\n  // ArcGIS Server only wants the numeric portion of the projection ID.\n  // (if there is no numeric portion the entire projection code must\n  // form a valid ArcGIS SpatialReference definition).\n  const srid = projection\n    .getCode()\n    .split(/:(?=\\d+$)/)\n    .pop();\n\n  const imageResolution = resolution / pixelRatio;\n\n  const imageSize = [\n    round(getWidth(extent) / imageResolution, DECIMALS),\n    round(getHeight(extent) / imageResolution, DECIMALS),\n  ];\n\n  params['SIZE'] = imageSize[0] + ',' + imageSize[1];\n  params['BBOX'] = extent.join(',');\n  params['BBOXSR'] = srid;\n  params['IMAGESR'] = srid;\n  params['DPI'] = Math.round(\n    params['DPI'] ? params['DPI'] * pixelRatio : 90 * pixelRatio,\n  );\n\n  const modifiedUrl = baseUrl\n    .replace(/MapServer\\/?$/, 'MapServer/export')\n    .replace(/ImageServer\\/?$/, 'ImageServer/exportImage');\n  return appendParams(modifiedUrl, params);\n}\n\n/**\n * @typedef {Object} LoaderOptions\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting the image from\n * the remote server.\n * @property {Object<string,*>} [params] ArcGIS Rest parameters. This field is optional. Service\n * defaults will be used for any fields not specified. `FORMAT` is `PNG32` by default. `F` is\n * `IMAGE` by default. `TRANSPARENT` is `true` by default.  `BBOX`, `SIZE`, `BBOXSR`, and `IMAGESR`\n * will be set dynamically. Set `LAYERS` to override the default service layer visibility. See\n * https://developers.arcgis.com/rest/services-reference/export-map.htm\n * for further reference.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is 'EPSG:3857'.\n * The projection code must contain a numeric end portion separated by :\n * or the entire code must form a valid ArcGIS SpatialReference definition.\n * @property {number} [ratio=1.5] Ratio. `1` means image requests are the size of the map viewport,\n * `2` means twice the size of the map viewport, and so on.\n * @property {string} url ArcGIS Rest service URL for a Map Service or Image Service. The url\n * should include /MapServer or /ImageServer.\n * @property {function(HTMLImageElement, string): Promise<import('../DataTile.js').ImageLike>} [load] Function\n * to perform loading of the image. Receives the created `HTMLImageElement` and the desired `src` as argument and\n * returns a promise resolving to the loaded or decoded image. Default is {@link module:ol/Image.decode}.\n */\n\n/**\n * Creates a loader for ArcGIS Rest images.\n * @param {LoaderOptions} options Image ArcGIS Rest Options.\n * @return {import('../Image.js').ImageObjectPromiseLoader} ArcGIS Rest image.\n * @api\n */\nexport function createLoader(options) {\n  const load = options.load ? options.load : decode;\n  const projection = getProjection(options.projection || 'EPSG:3857');\n  const ratio = options.ratio ?? 1.5;\n  const crossOrigin = options.crossOrigin ?? null;\n\n  /** @type {import('../Image.js').ImageObjectPromiseLoader} */\n  return function (extent, resolution, pixelRatio) {\n    pixelRatio = options.hidpi ? pixelRatio : 1;\n\n    const params = {\n      'F': 'image',\n      'FORMAT': 'PNG32',\n      'TRANSPARENT': true,\n    };\n    Object.assign(params, options.params);\n\n    extent = getRequestExtent(extent, resolution, pixelRatio, ratio);\n\n    const src = getRequestUrl(\n      options.url,\n      extent,\n      resolution,\n      pixelRatio,\n      projection,\n      params,\n    );\n\n    const image = new Image();\n    image.crossOrigin = crossOrigin;\n\n    return load(image, src).then((image) => {\n      // Update resolution, because the server may return a smaller size than requested\n      const resolution = (getWidth(extent) / image.width) * pixelRatio;\n      return {image, extent, resolution, pixelRatio};\n    });\n  };\n}\n", "/**\n * @module ol/source/ImageArcGISRest\n */\n\nimport ImageSource, {defaultImageLoadFunction} from './Image.js';\nimport {createLoader} from './arcgisRest.js';\nimport {decode} from '../Image.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting the image from\n * the remote server.\n * @property {import(\"../Image.js\").LoadFunction} [imageLoadFunction] Optional function to load an image given\n * a URL.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {Object<string,*>} [params] ArcGIS Rest parameters. This field is optional. Service\n * defaults will be used for any fields not specified. `FORMAT` is `PNG32` by default. `F` is\n * `IMAGE` by default. `TRANSPARENT` is `true` by default.  `BBOX`, `SIZE`, `BBOXSR`, and `IMAGESR`\n * will be set dynamically. Set `LAYERS` to override the default service layer visibility. See\n * https://developers.arcgis.com/rest/services-reference/export-map.htm\n * for further reference.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * The projection code must contain a numeric end portion separated by :\n * or the entire code must form a valid ArcGIS SpatialReference definition.\n * @property {number} [ratio=1.5] Ratio. `1` means image requests are the size of the map viewport,\n * `2` means twice the size of the map viewport, and so on.\n * @property {Array<number>} [resolutions] Resolutions. If specified, requests will be made for\n * these resolutions only.\n * @property {string} [url] ArcGIS Rest service URL for a Map Service or Image Service. The url\n * should include /MapServer or /ImageServer.\n */\n\n/**\n * @classdesc\n * Source for data from ArcGIS Rest services providing single, untiled images.\n * Useful when underlying map service has labels.\n *\n * If underlying map service is not using labels,\n * take advantage of ol image caching and use\n * {@link module:ol/source/TileArcGISRest~TileArcGISRest} data source.\n *\n * @fires module:ol/source/Image.ImageSourceEvent\n * @api\n */\nclass ImageArcGISRest extends ImageSource {\n  /**\n   * @param {Options} [options] Image ArcGIS Rest Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super({\n      attributions: options.attributions,\n      interpolate: options.interpolate,\n      projection: options.projection,\n      resolutions: options.resolutions,\n    });\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ =\n      options.crossOrigin !== undefined ? options.crossOrigin : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;\n\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.url_ = options.url;\n\n    /**\n     * @private\n     * @type {import(\"../Image.js\").LoadFunction}\n     */\n    this.imageLoadFunction_ =\n      options.imageLoadFunction !== undefined\n        ? options.imageLoadFunction\n        : defaultImageLoadFunction;\n\n    /**\n     * @private\n     * @type {!Object}\n     */\n    this.params_ = Object.assign({}, options.params);\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.imageSize_ = [0, 0];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;\n\n    /**\n     * @private\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.loaderProjection_ = null;\n  }\n\n  /**\n   * Get the user-provided params, i.e. those passed to the constructor through\n   * the \"params\" option, and possibly updated using the updateParams method.\n   * @return {Object} Params.\n   * @api\n   */\n  getParams() {\n    return this.params_;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../Image.js\").default} Single image.\n   * @override\n   */\n  getImageInternal(extent, resolution, pixelRatio, projection) {\n    if (this.url_ === undefined) {\n      return null;\n    }\n    if (!this.loader || this.loaderProjection_ !== projection) {\n      // Lazily create loader to pick up the view projection and to allow `params` updates\n      this.loaderProjection_ = projection;\n      this.loader = createLoader({\n        crossOrigin: this.crossOrigin_,\n        params: this.params_,\n        projection: projection,\n        hidpi: this.hidpi_,\n        url: this.url_,\n        ratio: this.ratio_,\n        load: (image, src) => {\n          this.image.setImage(image);\n          this.imageLoadFunction_(this.image, src);\n          return decode(image);\n        },\n      });\n    }\n\n    return super.getImageInternal(extent, resolution, pixelRatio, projection);\n  }\n\n  /**\n   * Return the image load function of the source.\n   * @return {import(\"../Image.js\").LoadFunction} The image load function.\n   * @api\n   */\n  getImageLoadFunction() {\n    return this.imageLoadFunction_;\n  }\n\n  /**\n   * Return the URL used for this ArcGIS source.\n   * @return {string|undefined} URL.\n   * @api\n   */\n  getUrl() {\n    return this.url_;\n  }\n\n  /**\n   * Set the image load function of the source.\n   * @param {import(\"../Image.js\").LoadFunction} imageLoadFunction Image load function.\n   * @api\n   */\n  setImageLoadFunction(imageLoadFunction) {\n    this.imageLoadFunction_ = imageLoadFunction;\n    this.changed();\n  }\n\n  /**\n   * Set the URL to use for requests.\n   * @param {string|undefined} url URL.\n   * @api\n   */\n  setUrl(url) {\n    if (url != this.url_) {\n      this.url_ = url;\n      this.loader = null;\n      this.changed();\n    }\n  }\n\n  /**\n   * Update the user-provided params.\n   * @param {Object} params Params.\n   * @api\n   */\n  updateParams(params) {\n    Object.assign(this.params_, params);\n    this.changed();\n  }\n\n  /**\n   * @override\n   */\n  changed() {\n    this.image = null;\n    super.changed();\n  }\n}\n\nexport default ImageArcGISRest;\n", "/**\n * @module ol/source/ImageCanvas\n */\n\nimport ImageCanvas from '../ImageCanvas.js';\nimport ImageSource from './Image.js';\nimport {\n  containsExtent,\n  getHeight,\n  getWidth,\n  scaleFromCenter,\n} from '../extent.js';\n\n/**\n * A function returning the canvas element (`{HTMLCanvasElement}`)\n * used by the source as an image. The arguments passed to the function are:\n * {@link module:ol/extent~Extent} the image extent, `{number}` the image resolution,\n * `{number}` the pixel ratio of the map, {@link module:ol/size~Size} the image size,\n * and {@link module:ol/proj/Projection~Projection} the image projection. The canvas returned by\n * this function is cached by the source. The this keyword inside the function\n * references the {@link module:ol/source/ImageCanvas~ImageCanvasSource}.\n *\n * @typedef {function(this:import(\"../ImageCanvas.js\").default, import(\"../extent.js\").Extent, number,\n *     number, import(\"../size.js\").Size, import(\"../proj/Projection.js\").default): HTMLCanvasElement} FunctionType\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {FunctionType} [canvasFunction] Canvas function.\n * The function returning the canvas element used by the source\n * as an image. The arguments passed to the function are: {@link import(\"../extent.js\").Extent} the\n * image extent, `{number}` the image resolution, `{number}` the pixel ratio of the map,\n * {@link import(\"../size.js\").Size} the image size, and {@link import(\"../proj/Projection.js\").default} the image\n * projection. The canvas returned by this function is cached by the source. If\n * the value returned by the function is later changed then\n * `changed` should be called on the source for the source to\n * invalidate the current cached image. See: {@link module:ol/Observable~Observable#changed}\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {number} [ratio=1.5] Ratio. 1 means canvases are the size of the map viewport, 2 means twice the\n * width and height of the map viewport, and so on. Must be `1` or higher.\n * @property {Array<number>} [resolutions] Resolutions.\n * If specified, new canvases will be created for these resolutions\n * @property {import(\"./Source.js\").State} [state] Source state.\n */\n\n/**\n * @classdesc\n * Base class for image sources where a canvas element is the image.\n * @api\n */\nclass ImageCanvasSource extends ImageSource {\n  /**\n   * @param {Options} [options] ImageCanvas options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super({\n      attributions: options.attributions,\n      interpolate: options.interpolate,\n      projection: options.projection,\n      resolutions: options.resolutions,\n      state: options.state,\n    });\n\n    /**\n     * @private\n     * @type {FunctionType}\n     */\n    this.canvasFunction_ = options.canvasFunction;\n\n    /**\n     * @private\n     * @type {import(\"../ImageCanvas.js\").default}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../ImageCanvas.js\").default} Single image.\n   * @override\n   */\n  getImageInternal(extent, resolution, pixelRatio, projection) {\n    resolution = this.findNearestResolution(resolution);\n\n    let canvas = this.canvas_;\n    if (\n      canvas &&\n      this.renderedRevision_ == this.getRevision() &&\n      canvas.getResolution() == resolution &&\n      canvas.getPixelRatio() == pixelRatio &&\n      containsExtent(canvas.getExtent(), extent)\n    ) {\n      return canvas;\n    }\n\n    extent = extent.slice();\n    scaleFromCenter(extent, this.ratio_);\n    const width = getWidth(extent) / resolution;\n    const height = getHeight(extent) / resolution;\n    const size = [width * pixelRatio, height * pixelRatio];\n\n    const canvasElement = this.canvasFunction_.call(\n      this,\n      extent,\n      resolution,\n      pixelRatio,\n      size,\n      projection,\n    );\n    if (canvasElement) {\n      canvas = new ImageCanvas(extent, resolution, pixelRatio, canvasElement);\n    }\n    this.canvas_ = canvas;\n    this.renderedRevision_ = this.getRevision();\n\n    return canvas;\n  }\n}\n\nexport default ImageCanvasSource;\n", "/**\n * @module ol/source/mapguide\n */\n\nimport {appendParams} from '../uri.js';\nimport {decode} from '../Image.js';\nimport {getCenter, getHeight, getWidth} from '../extent.js';\nimport {getRequestExtent} from './Image.js';\n\n/**\n * @typedef {Object} LoaderOptions\n * @property {string} url The mapagent url.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {number} [displayDpi=96] The display resolution.\n * @property {number} [metersPerUnit=1] The meters-per-unit value.\n * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting\n * the image from the remote server.\n * @property {boolean} [useOverlay] If `true`, will use `GETDYNAMICMAPOVERLAYIMAGE`.\n * @property {number} [ratio=1] Ratio. `1` means image requests are the size of the map viewport, `2` means\n * twice the width and height of the map viewport, and so on. Must be `1` or higher.\n * @property {Object} [params] Additional query parameters.\n * @property {function(HTMLImageElement, string): Promise<import('../DataTile.js').ImageLike>} [load] Function\n * to perform loading of the image. Receives the created `HTMLImageElement` and the desired `src` as argument and\n * returns a promise resolving to the loaded or decoded image. Default is {@link module:ol/Image.decode}.\n */\n\n/**\n * @param {import(\"../extent.js\").Extent} extent The map extents.\n * @param {import(\"../size.js\").Size} size The viewport size.\n * @param {number} metersPerUnit The meters-per-unit value.\n * @param {number} dpi The display resolution.\n * @return {number} The computed map scale.\n */\nfunction getScale(extent, size, metersPerUnit, dpi) {\n  const mcsW = getWidth(extent);\n  const mcsH = getHeight(extent);\n  const devW = size[0];\n  const devH = size[1];\n  const mpp = 0.0254 / dpi;\n  if (devH * mcsW > devW * mcsH) {\n    return (mcsW * metersPerUnit) / (devW * mpp); // width limited\n  }\n  return (mcsH * metersPerUnit) / (devH * mpp); // height limited\n}\n\n/**\n * @param {string} baseUrl The mapagent url.\n * @param {Object<string, string|number>} params Request parameters.\n * @param {import(\"../extent.js\").Extent} extent Extent.\n * @param {import(\"../size.js\").Size} size Size.\n * @param {boolean} useOverlay If `true`, will use `GETDYNAMICMAPOVERLAYIMAGE`.\n * @param {number} metersPerUnit The meters-per-unit value.\n * @param {number} displayDpi The display resolution.\n * @return {string} The mapagent map image request URL.\n */\nfunction getUrl(\n  baseUrl,\n  params,\n  extent,\n  size,\n  useOverlay,\n  metersPerUnit,\n  displayDpi,\n) {\n  const scale = getScale(extent, size, metersPerUnit, displayDpi);\n  const center = getCenter(extent);\n  const baseParams = {\n    'OPERATION': useOverlay ? 'GETDYNAMICMAPOVERLAYIMAGE' : 'GETMAPIMAGE',\n    'VERSION': '2.0.0',\n    'LOCALE': 'en',\n    'CLIENTAGENT': 'ol/source/ImageMapGuide source',\n    'CLIP': '1',\n    'SETDISPLAYDPI': displayDpi,\n    'SETDISPLAYWIDTH': Math.round(size[0]),\n    'SETDISPLAYHEIGHT': Math.round(size[1]),\n    'SETVIEWSCALE': scale,\n    'SETVIEWCENTERX': center[0],\n    'SETVIEWCENTERY': center[1],\n  };\n  Object.assign(baseParams, params);\n  return appendParams(baseUrl, baseParams);\n}\n\n/**\n * Creates a loader for MapGuide images.\n * @param {LoaderOptions} options Image ArcGIS Rest Options.\n * @return {import('../Image.js').ImageObjectPromiseLoader} ArcGIS Rest image.\n * @api\n */\nexport function createLoader(options) {\n  const load = options.load || decode;\n  const useOverlay = options.useOverlay ?? false;\n  const metersPerUnit = options.metersPerUnit || 1;\n  const displayDpi = options.displayDpi || 96;\n  const ratio = options.ratio ?? 1;\n  const crossOrigin = options.crossOrigin ?? null;\n\n  /** @type {import('../Image.js').ImageObjectPromiseLoader} */\n  return function (extent, resolution, pixelRatio) {\n    const image = new Image();\n    image.crossOrigin = crossOrigin;\n    extent = getRequestExtent(extent, resolution, pixelRatio, ratio);\n    const width = getWidth(extent) / resolution;\n    const height = getHeight(extent) / resolution;\n    const size = [width * pixelRatio, height * pixelRatio];\n    const src = getUrl(\n      options.url,\n      options.params,\n      extent,\n      size,\n      useOverlay,\n      metersPerUnit,\n      displayDpi,\n    );\n    return load(image, src).then((image) => ({image, extent, pixelRatio}));\n  };\n}\n", "/**\n * @module ol/source/ImageMapGuide\n */\n\nimport ImageSource, {defaultImageLoadFunction} from './Image.js';\nimport {createLoader} from './mapguide.js';\nimport {decode} from '../Image.js';\n\n/**\n * @typedef {Object} Options\n * @property {string} [url] The mapagent url.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {number} [displayDpi=96] The display resolution.\n * @property {number} [metersPerUnit=1] The meters-per-unit value.\n * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting\n * the image from the remote server.\n * @property {boolean} [useOverlay] If `true`, will use `GETDYNAMICMAPOVERLAYIMAGE`.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {number} [ratio=1] Ratio. `1` means image requests are the size of the map viewport, `2` means\n * twice the width and height of the map viewport, and so on. Must be `1` or higher.\n * @property {Array<number>} [resolutions] Resolutions.\n * If specified, requests will be made for these resolutions only.\n * @property {import(\"../Image.js\").LoadFunction} [imageLoadFunction] Optional function to load an image given a URL.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {Object} [params] Additional parameters.\n */\n\n/**\n * @classdesc\n * Source for images from Mapguide servers\n *\n * @fires module:ol/source/Image.ImageSourceEvent\n * @api\n */\nclass ImageMapGuide extends ImageSource {\n  /**\n   * @param {Options} options ImageMapGuide options.\n   */\n  constructor(options) {\n    super({\n      interpolate: options.interpolate,\n      projection: options.projection,\n      resolutions: options.resolutions,\n    });\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ =\n      options.crossOrigin !== undefined ? options.crossOrigin : null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.displayDpi_ =\n      options.displayDpi !== undefined ? options.displayDpi : 96;\n\n    /**\n     * @private\n     * @type {!Object}\n     */\n    this.params_ = Object.assign({}, options.params);\n\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.url_ = options.url;\n\n    /**\n     * @private\n     * @type {import(\"../Image.js\").LoadFunction}\n     */\n    this.imageLoadFunction_ =\n      options.imageLoadFunction !== undefined\n        ? options.imageLoadFunction\n        : defaultImageLoadFunction;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.metersPerUnit_ =\n      options.metersPerUnit !== undefined ? options.metersPerUnit : 1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.ratio_ = options.ratio !== undefined ? options.ratio : 1;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.useOverlay_ =\n      options.useOverlay !== undefined ? options.useOverlay : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = 0;\n\n    /**\n     * @private\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.loaderProjection_ = null;\n  }\n\n  /**\n   * Get the user-provided params, i.e. those passed to the constructor through\n   * the \"params\" option, and possibly updated using the updateParams method.\n   * @return {Object} Params.\n   * @api\n   */\n  getParams() {\n    return this.params_;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../Image.js\").default} Single image.\n   * @override\n   */\n  getImageInternal(extent, resolution, pixelRatio, projection) {\n    if (this.url_ === undefined) {\n      return null;\n    }\n    if (!this.loader || this.loaderProjection_ !== projection) {\n      // Lazily create loader to pick up the view projection and to allow `params` updates\n      this.loaderProjection_ = projection;\n      this.loader = createLoader({\n        crossOrigin: this.crossOrigin_,\n        params: this.params_,\n        hidpi: this.hidpi_,\n        metersPerUnit: this.metersPerUnit_,\n        url: this.url_,\n        useOverlay: this.useOverlay_,\n        ratio: this.ratio_,\n        load: (image, src) => {\n          this.image.setImage(image);\n          this.imageLoadFunction_(this.image, src);\n          return decode(image);\n        },\n      });\n    }\n\n    return super.getImageInternal(extent, resolution, pixelRatio, projection);\n  }\n\n  /**\n   * Return the image load function of the source.\n   * @return {import(\"../Image.js\").LoadFunction} The image load function.\n   * @api\n   */\n  getImageLoadFunction() {\n    return this.imageLoadFunction_;\n  }\n\n  /**\n   * Update the user-provided params.\n   * @param {Object} params Params.\n   * @api\n   */\n  updateParams(params) {\n    Object.assign(this.params_, params);\n    this.changed();\n  }\n\n  /**\n   * Set the image load function of the MapGuide source.\n   * @param {import(\"../Image.js\").LoadFunction} imageLoadFunction Image load function.\n   * @api\n   */\n  setImageLoadFunction(imageLoadFunction) {\n    this.imageLoadFunction_ = imageLoadFunction;\n    this.changed();\n  }\n\n  /**\n   * @override\n   */\n  changed() {\n    this.image = null;\n    super.changed();\n  }\n}\n\nexport default ImageMapGuide;\n", "/**\n * @module ol/source/static\n */\n\nimport {decode} from '../Image.js';\nimport {getHeight, getWidth} from '../extent.js';\n\n/**\n * @typedef {Object} LoaderOptions\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {import(\"../extent.js\").Extent} imageExtent Extent of the image in map coordinates.\n * This is the [left, bottom, right, top] map coordinates of your image. When using this loader with an\n * `ol/source/Image`, the same extent must be set as `extent` of the `ol/layer/Image`.\n * @property {string} url Image URL.\n * @property {function(HTMLImageElement, string): Promise<import('../DataTile.js').ImageLike>} [load] Function\n * to perform loading of the image. Receives the created `HTMLImageElement` and the desired `src` as argument and\n * returns a promise resolving to the loaded or decoded image. Default is {@link module:ol/Image.decode}.\n */\n\n/**\n * Creates a loader for static images.\n * @param {LoaderOptions} options Loader options.\n * @return {import(\"../Image.js\").ImageObjectPromiseLoader} Loader.\n * @api\n */\nexport function createLoader(options) {\n  const load = options.load || decode;\n  const extent = options.imageExtent;\n  const crossOrigin = options.crossOrigin ?? null;\n\n  return () => {\n    const image = new Image();\n    image.crossOrigin = crossOrigin;\n    return load(image, options.url).then((image) => {\n      const resolutionX = getWidth(extent) / image.width;\n      const resolutionY = getHeight(extent) / image.height;\n      const resolution =\n        resolutionX !== resolutionY ? [resolutionX, resolutionY] : resolutionY;\n      return {image, extent, resolution, pixelRatio: 1};\n    });\n  };\n}\n", "/**\n * @module ol/source/ImageStatic\n */\n\nimport EventType from '../events/EventType.js';\nimport ImageSource, {defaultImageLoadFunction} from './Image.js';\nimport ImageWrapper, {decode} from '../Image.js';\nimport {createLoader} from './static.js';\nimport {get as getProjection} from '../proj.js';\nimport {intersects} from '../extent.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {import(\"../extent.js\").Extent} imageExtent Extent of the image in map coordinates.\n * This is the [left, bottom, right, top] map coordinates of your image.\n * @property {import(\"../Image.js\").LoadFunction} [imageLoadFunction] Optional function to load an image given a URL.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {string} url Image URL.\n */\n\n/**\n * @classdesc\n * A layer source for displaying a single, static image.\n * @api\n */\nclass Static extends ImageSource {\n  /**\n   * @param {Options} options ImageStatic options.\n   */\n  constructor(options) {\n    const crossOrigin =\n      options.crossOrigin !== undefined ? options.crossOrigin : null;\n\n    const /** @type {import(\"../Image.js\").LoadFunction} */ imageLoadFunction =\n        options.imageLoadFunction !== undefined\n          ? options.imageLoadFunction\n          : defaultImageLoadFunction;\n\n    super({\n      attributions: options.attributions,\n      interpolate: options.interpolate,\n      projection: getProjection(options.projection),\n    });\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.url_ = options.url;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.imageExtent_ = options.imageExtent;\n\n    /**\n     * @private\n     * @type {import(\"../Image.js\").default}\n     */\n    this.image = null;\n\n    this.image = new ImageWrapper(\n      this.imageExtent_,\n      undefined,\n      1,\n      createLoader({\n        url: options.url,\n        imageExtent: options.imageExtent,\n        crossOrigin,\n        load: (image, src) => {\n          this.image.setImage(image);\n          imageLoadFunction(this.image, src);\n          return decode(image);\n        },\n      }),\n    );\n\n    this.image.addEventListener(\n      EventType.CHANGE,\n      this.handleImageChange.bind(this),\n    );\n  }\n\n  /**\n   * Returns the image extent\n   * @return {import(\"../extent.js\").Extent} image extent.\n   * @api\n   */\n  getImageExtent() {\n    return this.imageExtent_;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../Image.js\").default} Single image.\n   * @override\n   */\n  getImageInternal(extent, resolution, pixelRatio, projection) {\n    if (intersects(extent, this.image.getExtent())) {\n      return this.image;\n    }\n    return null;\n  }\n\n  /**\n   * Return the URL used for this image source.\n   * @return {string} URL.\n   * @api\n   */\n  getUrl() {\n    return this.url_;\n  }\n}\n\nexport default Static;\n", "/**\n * @module ol/source/ImageTile\n */\nimport DataTileSource from './DataTile.js';\nimport {expandUrl, pickUrl, renderXYZTemplate} from '../uri.js';\n\n/**\n * Image tile loading function.  The function is called with z, x, and y tile coordinates and\n * returns an {@link import(\"../DataTile.js\").ImageLike image} or a promise for the same.\n *\n * @typedef {function(number, number, number, import(\"./DataTile.js\").LoaderOptions):(import(\"../DataTile.js\").ImageLike|Promise<import(\"../DataTile.js\").ImageLike>)} Loader\n */\n\n/**\n * @typedef {function(number, number, number, import(\"./DataTile.js\").LoaderOptions):string} UrlGetter\n */\n\n/**\n * @typedef {string | Array<string> | UrlGetter} UrlLike\n */\n\n/**\n * @typedef {Object} Options\n * @property {UrlLike} [url] The image URL template.  In addition to a single URL template, an array of URL templates or a function\n * can be provided.  If a function is provided, it will be called with z, x, y tile coordinates and loader options and should\n * return a URL.\n * @property {Loader} [loader] Data loader.  Called with z, x, and y tile coordinates.\n * Returns an {@link import(\"../DataTile.js\").ImageLike image} for a tile or a promise for the same.\n * The promise should not resolve until the image is loaded.  If the `url` option is provided, a loader will be created.\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The pixel width and height of the source tiles.\n * This may be different than the rendered pixel size if a `tileGrid` is provided.\n * @property {number} [gutter=0] The size in pixels of the gutter around data tiles to ignore.\n * This allows artifacts of rendering at tile edges to be ignored.\n * Supported data should be wider and taller than the tile size by a value of `2 x gutter`.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Tile projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"./Source.js\").State} [state] The source state.\n * @property {boolean} [wrapX=true] Render tiles beyond the antimeridian.\n * @property {number} [transition] Transition time when fading in new tiles (in miliseconds).\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.\n * @property {import('./DataTile.js').CrossOriginAttribute} [crossOrigin='anonymous'] The crossOrigin property to pass to loaders for image data.\n */\n\nconst loadError = new Error('Image failed to load');\n\n/**\n * @param {string} template The image url template.\n * @param {number} z The tile z coordinate.\n * @param {number} x The tile x coordinate.\n * @param {number} y The tile y coordinate.\n * @param {import('./DataTile.js').LoaderOptions} options The loader options.\n * @return {Promise<HTMLImageElement>} Resolves with a loaded image.\n */\nfunction loadImage(template, z, x, y, options) {\n  return new Promise((resolve, reject) => {\n    const image = new Image();\n    image.crossOrigin = options.crossOrigin ?? null;\n    image.addEventListener('load', () => resolve(image));\n    image.addEventListener('error', () => reject(loadError));\n    image.src = renderXYZTemplate(template, z, x, y, options.maxY);\n  });\n}\n\n/**\n * @param {Array<string>} templates The url templates.\n * @return {Loader} The image loader.\n */\nfunction makeLoaderFromTemplates(templates) {\n  return function (z, x, y, options) {\n    const template = pickUrl(templates, z, x, y);\n    return loadImage(template, z, x, y, options);\n  };\n}\n\n/**\n * @param {UrlGetter} getter The url getter.\n * @return {Loader} The image loader.\n */\nfunction makeLoaderFromGetter(getter) {\n  return function (z, x, y, options) {\n    const url = getter(z, x, y, options);\n    return loadImage(url, z, x, y, options);\n  };\n}\n\n/**\n * @param {UrlLike} url The URL-like option.\n * @return {Loader} The tile loader.\n */\nfunction makeLoaderFromUrlLike(url) {\n  /**\n   * @type {Loader}\n   */\n  let loader;\n\n  if (Array.isArray(url)) {\n    loader = makeLoaderFromTemplates(url);\n  } else if (typeof url === 'string') {\n    const urls = expandUrl(url);\n    loader = makeLoaderFromTemplates(urls);\n  } else if (typeof url === 'function') {\n    loader = makeLoaderFromGetter(url);\n  } else {\n    throw new Error(\n      'The url option must be a single template, an array of templates, or a function for getting a URL',\n    );\n  }\n  return loader;\n}\n\nlet keyCount = 0;\n\n/**\n * @param {UrlLike} url The URL-like option.\n * @return {string} A key for the URL.\n */\nfunction keyFromUrlLike(url) {\n  if (Array.isArray(url)) {\n    return url.join('\\n');\n  }\n\n  if (typeof url === 'string') {\n    return url;\n  }\n\n  ++keyCount;\n  return 'url-function-key-' + keyCount;\n}\n\n/**\n * @classdesc\n * A source for typed array data tiles.\n *\n * @extends DataTileSource<import(\"../ImageTile.js\").default>\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nclass ImageTileSource extends DataTileSource {\n  /**\n   * @param {Options} [options] DataTile source options.\n   */\n  constructor(options) {\n    options = options || {};\n\n    /**\n     * @type {Loader}\n     */\n    let loader = options.loader;\n\n    /**\n     * @type {string}\n     */\n    let key;\n\n    if (options.url) {\n      loader = makeLoaderFromUrlLike(options.url);\n      key = keyFromUrlLike(options.url);\n    }\n\n    /**\n     * @type {import('./Source.js').State}\n     */\n    const state = !loader ? 'loading' : options.state;\n\n    const wrapX = options.wrapX === undefined ? true : options.wrapX;\n\n    super({\n      loader: loader,\n      key: key,\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      maxZoom: options.maxZoom,\n      minZoom: options.minZoom,\n      tileSize: options.tileSize,\n      gutter: options.gutter,\n      maxResolution: options.maxResolution,\n      projection: options.projection,\n      tileGrid: options.tileGrid,\n      state: state,\n      wrapX: wrapX,\n      transition: options.transition,\n      interpolate: options.interpolate !== false,\n      crossOrigin: options.crossOrigin,\n    });\n  }\n\n  /**\n   * @param {UrlLike} url The new URL.\n   * @api\n   */\n  setUrl(url) {\n    const loader = makeLoaderFromUrlLike(url);\n    this.setLoader(loader);\n    this.setKey(keyFromUrlLike(url));\n    if (this.getState() !== 'ready') {\n      this.setState('ready');\n    }\n  }\n}\n\nexport default ImageTileSource;\n", "/**\n * @module ol/source/ImageWMS\n */\n\nimport ImageSource, {defaultImageLoadFunction} from './Image.js';\nimport {calculateSourceResolution} from '../reproj.js';\nimport {createLoader, getFeatureInfoUrl, getLegendUrl} from './wms.js';\nimport {decode} from '../Image.js';\nimport {get as getProjection, transform} from '../proj.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting\n * the image from the remote server.\n * @property {import(\"./wms.js\").ServerType} [serverType] The type of\n * the remote WMS server: `mapserver`, `geoserver`, `carmentaserver`, or `qgis`.\n * Only needed if `hidpi` is `true`.\n * @property {import(\"../Image.js\").LoadFunction} [imageLoadFunction] Optional function to load an image given a URL.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {Object<string,*>} [params] WMS request parameters.\n * At least a `LAYERS` param is required. `STYLES` is\n * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT`, `BBOX`\n * and `CRS` (`SRS` for WMS version < 1.3.0) will be set dynamically.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {number} [ratio=1.5] Ratio. `1` means image requests are the size of the map viewport, `2` means\n * twice the width and height of the map viewport, and so on. Must be `1` or higher.\n * @property {Array<number>} [resolutions] Resolutions.\n * If specified, requests will be made for these resolutions only.\n * @property {string} [url] WMS service URL.\n */\n\n/**\n * @classdesc\n * Source for WMS servers providing single, untiled images.\n *\n * @fires module:ol/source/Image.ImageSourceEvent\n * @api\n */\nclass ImageWMS extends ImageSource {\n  /**\n   * @param {Options} [options] ImageWMS options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super({\n      attributions: options.attributions,\n      interpolate: options.interpolate,\n      projection: options.projection,\n      resolutions: options.resolutions,\n    });\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ =\n      options.crossOrigin !== undefined ? options.crossOrigin : null;\n\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.url_ = options.url;\n\n    /**\n     * @private\n     * @type {import(\"../Image.js\").LoadFunction}\n     */\n    this.imageLoadFunction_ =\n      options.imageLoadFunction !== undefined\n        ? options.imageLoadFunction\n        : defaultImageLoadFunction;\n\n    /**\n     * @private\n     * @type {!Object}\n     */\n    this.params_ = Object.assign({}, options.params);\n\n    /**\n     * @private\n     * @type {import(\"./wms.js\").ServerType}\n     */\n    this.serverType_ = options.serverType;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;\n\n    /**\n     * @private\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.loaderProjection_ = null;\n  }\n\n  /**\n   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and\n   * projection. Return `undefined` if the GetFeatureInfo URL cannot be\n   * constructed.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should\n   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified\n   *     in the `LAYERS` parameter will be used. `VERSION` should not be\n   *     specified here.\n   * @return {string|undefined} GetFeatureInfo URL.\n   * @api\n   */\n  getFeatureInfoUrl(coordinate, resolution, projection, params) {\n    const projectionObj = getProjection(projection);\n    const sourceProjectionObj = this.getProjection();\n\n    if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {\n      resolution = calculateSourceResolution(\n        sourceProjectionObj,\n        projectionObj,\n        coordinate,\n        resolution,\n      );\n      coordinate = transform(coordinate, projectionObj, sourceProjectionObj);\n    }\n\n    const options = {\n      url: this.url_,\n      params: {\n        ...this.params_,\n        ...params,\n      },\n      projection: sourceProjectionObj || projectionObj,\n    };\n    return getFeatureInfoUrl(options, coordinate, resolution);\n  }\n\n  /**\n   * Return the GetLegendGraphic URL, optionally optimized for the passed\n   * resolution and possibly including any passed specific parameters. Returns\n   * `undefined` if the GetLegendGraphic URL cannot be constructed.\n   *\n   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`\n   *     will not be calculated and included in URL.\n   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the\n   *     request is generated for this wms layer, else it will try to use the\n   *     configured wms layer. Default `FORMAT` is `image/png`.\n   *     `VERSION` should not be specified here.\n   * @return {string|undefined} GetLegendGraphic URL.\n   * @api\n   */\n  getLegendUrl(resolution, params) {\n    return getLegendUrl(\n      {\n        url: this.url_,\n        params: {\n          ...this.params_,\n          ...params,\n        },\n      },\n      resolution,\n    );\n  }\n\n  /**\n   * Get the user-provided params, i.e. those passed to the constructor through\n   * the \"params\" option, and possibly updated using the updateParams method.\n   * @return {Object} Params.\n   * @api\n   */\n  getParams() {\n    return this.params_;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../Image.js\").default} Single image.\n   * @override\n   */\n  getImageInternal(extent, resolution, pixelRatio, projection) {\n    if (this.url_ === undefined) {\n      return null;\n    }\n    if (!this.loader || this.loaderProjection_ !== projection) {\n      // Lazily create loader to pick up the view projection and to allow `params` updates\n      this.loaderProjection_ = projection;\n      this.loader = createLoader({\n        crossOrigin: this.crossOrigin_,\n        params: this.params_,\n        projection: projection,\n        serverType: this.serverType_,\n        hidpi: this.hidpi_,\n        url: this.url_,\n        ratio: this.ratio_,\n        load: (image, src) => {\n          this.image.setImage(image);\n          this.imageLoadFunction_(this.image, src);\n          return decode(image);\n        },\n      });\n    }\n\n    return super.getImageInternal(extent, resolution, pixelRatio, projection);\n  }\n\n  /**\n   * Return the image load function of the source.\n   * @return {import(\"../Image.js\").LoadFunction} The image load function.\n   * @api\n   */\n  getImageLoadFunction() {\n    return this.imageLoadFunction_;\n  }\n\n  /**\n   * Return the URL used for this WMS source.\n   * @return {string|undefined} URL.\n   * @api\n   */\n  getUrl() {\n    return this.url_;\n  }\n\n  /**\n   * Set the image load function of the source.\n   * @param {import(\"../Image.js\").LoadFunction} imageLoadFunction Image load function.\n   * @api\n   */\n  setImageLoadFunction(imageLoadFunction) {\n    this.imageLoadFunction_ = imageLoadFunction;\n    this.changed();\n  }\n\n  /**\n   * Set the URL to use for requests.\n   * @param {string|undefined} url URL.\n   * @api\n   */\n  setUrl(url) {\n    if (url != this.url_) {\n      this.url_ = url;\n      this.loader = null;\n      this.changed();\n    }\n  }\n\n  /**\n   * Update the user-provided params.\n   * @param {Object} params Params.\n   * @api\n   */\n  updateParams(params) {\n    Object.assign(this.params_, params);\n    this.changed();\n  }\n\n  /**\n   * @override\n   */\n  changed() {\n    this.image = null;\n    super.changed();\n  }\n}\n\nexport default ImageWMS;\n", "/**\n * @module ol/net\n */\nimport {getUid} from './util.js';\n\n/**\n * Simple JSONP helper. Supports error callbacks and a custom callback param.\n * The error callback will be called when no JSONP is executed after 10 seconds.\n *\n * @param {string} url Request url. A 'callback' query parameter will be\n *     appended.\n * @param {Function} callback Callback on success.\n * @param {Function} [errback] Callback on error.\n * @param {string} [callbackParam] Custom query parameter for the JSONP\n *     callback. Default is 'callback'.\n */\nexport function jsonp(url, callback, errback, callbackParam) {\n  const script = document.createElement('script');\n  const key = 'olc_' + getUid(callback);\n  function cleanup() {\n    delete window[key];\n    script.parentNode.removeChild(script);\n  }\n  script.async = true;\n  script.src =\n    url +\n    (url.includes('?') ? '&' : '?') +\n    (callbackParam || 'callback') +\n    '=' +\n    key;\n  const timer = setTimeout(function () {\n    cleanup();\n    if (errback) {\n      errback();\n    }\n  }, 10000);\n  window[key] = function (data) {\n    clearTimeout(timer);\n    cleanup();\n    callback(data);\n  };\n  document.head.appendChild(script);\n}\n\nexport class ResponseError extends Error {\n  /**\n   * @param {XMLHttpRequest} response The XHR object.\n   */\n  constructor(response) {\n    const message = 'Unexpected response status: ' + response.status;\n    super(message);\n\n    /**\n     * @type {string}\n     */\n    this.name = 'ResponseError';\n\n    /**\n     * @type {XMLHttpRequest}\n     */\n    this.response = response;\n  }\n}\n\nexport class ClientError extends Error {\n  /**\n   * @param {XMLHttpRequest} client The XHR object.\n   */\n  constructor(client) {\n    super('Failed to issue request');\n\n    /**\n     * @type {string}\n     */\n    this.name = 'ClientError';\n\n    /**\n     * @type {XMLHttpRequest}\n     */\n    this.client = client;\n  }\n}\n\n/**\n * @param {string} url The URL.\n * @return {Promise<Object>} A promise that resolves to the JSON response.\n */\nexport function getJSON(url) {\n  return new Promise(function (resolve, reject) {\n    /**\n     * @param {ProgressEvent<XMLHttpRequest>} event The load event.\n     */\n    function onLoad(event) {\n      const client = event.target;\n      // status will be 0 for file:// urls\n      if (!client.status || (client.status >= 200 && client.status < 300)) {\n        let data;\n        try {\n          data = JSON.parse(client.responseText);\n        } catch (err) {\n          const message = 'Error parsing response text as JSON: ' + err.message;\n          reject(new Error(message));\n          return;\n        }\n        resolve(data);\n        return;\n      }\n\n      reject(new ResponseError(client));\n    }\n\n    /**\n     * @param {ProgressEvent<XMLHttpRequest>} event The error event.\n     */\n    function onError(event) {\n      reject(new ClientError(event.target));\n    }\n\n    const client = new XMLHttpRequest();\n    client.addEventListener('load', onLoad);\n    client.addEventListener('error', onError);\n    client.open('GET', url);\n    client.setRequestHeader('Accept', 'application/json');\n    client.send();\n  });\n}\n\n/**\n * @param {string} base The base URL.\n * @param {string} url The potentially relative URL.\n * @return {string} The full URL.\n */\nexport function resolveUrl(base, url) {\n  if (url.includes('://')) {\n    return url;\n  }\n  return new URL(url, base).href;\n}\n\nlet originalXHR;\nexport function overrideXHR(xhr) {\n  if (typeof XMLHttpRequest !== 'undefined') {\n    originalXHR = XMLHttpRequest;\n  }\n  global.XMLHttpRequest = xhr;\n}\n\nexport function restoreXHR() {\n  global.XMLHttpRequest = originalXHR;\n}\n", "/**\n * @module ol/source/ogcTileUtil\n */\n\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport {getJSON, resolveUrl} from '../net.js';\nimport {get as getProjection} from '../proj.js';\nimport {getIntersection as intersectExtents} from '../extent.js';\nimport {error as logError} from '../console.js';\n\n/**\n * See https://ogcapi.ogc.org/tiles/.\n */\n\n/**\n * @typedef {'map' | 'vector'} TileType\n */\n\n/**\n * @typedef {'topLeft' | 'bottomLeft'} CornerOfOrigin\n */\n\n/**\n * @typedef {Object} TileSet\n * @property {TileType} dataType Type of data represented in the tileset.\n * @property {string} [tileMatrixSetDefinition] Reference to a tile matrix set definition.\n * @property {TileMatrixSet} [tileMatrixSet] Tile matrix set definition.\n * @property {Array<TileMatrixSetLimit>} [tileMatrixSetLimits] Tile matrix set limits.\n * @property {Array<Link>} links Tileset links.\n */\n\n/**\n * @typedef {Object} Link\n * @property {string} rel The link rel attribute.\n * @property {string} href The link URL.\n * @property {string} type The link type.\n */\n\n/**\n * @typedef {Object} TileMatrixSetLimit\n * @property {string} tileMatrix The tile matrix id.\n * @property {number} minTileRow The minimum tile row.\n * @property {number} maxTileRow The maximum tile row.\n * @property {number} minTileCol The minimum tile column.\n * @property {number} maxTileCol The maximum tile column.\n */\n\n/**\n * @typedef {Object} TileMatrixSet\n * @property {string} id The tile matrix set identifier.\n * @property {string} crs The coordinate reference system.\n * @property {Array<string>} [orderedAxes] Axis order.\n * @property {Array<TileMatrix>} tileMatrices Array of tile matrices.\n */\n\n/**\n * @typedef {Object} TileMatrix\n * @property {string} id The tile matrix identifier.\n * @property {number} cellSize The pixel resolution (map units per pixel).\n * @property {Array<number>} pointOfOrigin The map location of the matrix origin.\n * @property {CornerOfOrigin} [cornerOfOrigin='topLeft'] The corner of the matrix that represents the origin ('topLeft' or 'bottomLeft').\n * @property {number} matrixWidth The number of columns.\n * @property {number} matrixHeight The number of rows.\n * @property {number} tileWidth The pixel width of a tile.\n * @property {number} tileHeight The pixel height of a tile.\n */\n\n/**\n * @type {Object<string, boolean>}\n */\nconst knownMapMediaTypes = {\n  'image/png': true,\n  'image/jpeg': true,\n  'image/gif': true,\n  'image/webp': true,\n};\n\n/**\n * @type {Object<string, boolean>}\n */\nconst knownVectorMediaTypes = {\n  'application/vnd.mapbox-vector-tile': true,\n  'application/geo+json': true,\n};\n\n/**\n * @typedef {Object} TileSetInfo\n * @property {string} urlTemplate The tile URL template.\n * @property {import(\"../tilegrid/TileGrid.js\").default} grid The tile grid.\n * @property {import(\"../Tile.js\").UrlFunction} urlFunction The tile URL function.\n */\n\n/**\n * @typedef {Object} SourceInfo\n * @property {string} url The tile set URL.\n * @property {string} mediaType The preferred tile media type.\n * @property {Array<string>} [supportedMediaTypes] The supported media types.\n * @property {import(\"../proj/Projection.js\").default} projection The source projection.\n * @property {Object} [context] Optional context for constructing the URL.\n * @property {Array<string>} [collections] Optional collections to append the URL with.\n */\n\n/**\n * @param {string} tileUrlTemplate Tile URL template.\n * @param {Array<string>} collections List of collections to include as query parameter.\n * @return {string} The tile URL template with appended collections query parameter.\n */\nexport function appendCollectionsQueryParam(tileUrlTemplate, collections) {\n  if (!collections.length) {\n    return tileUrlTemplate;\n  }\n\n  // making sure we can always construct a URL instance.\n  const url = new URL(tileUrlTemplate, 'file:/');\n\n  if (url.pathname.split('/').includes('collections')) {\n    logError(\n      'The \"collections\" query parameter cannot be added to collection endpoints',\n    );\n    return tileUrlTemplate;\n  }\n  // According to conformance class\n  // http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/collections-selection\n  // commata in the identifiers of the `collections` query parameter\n  // need to be URLEncoded, while the commata separating the identifiers\n  // should not.\n  const encodedCollections = collections\n    .map((c) => encodeURIComponent(c))\n    .join(',');\n\n  url.searchParams.append('collections', encodedCollections);\n  const baseUrl = tileUrlTemplate.split('?')[0];\n  const queryParams = decodeURIComponent(url.searchParams.toString());\n  return `${baseUrl}?${queryParams}`;\n}\n\n/**\n * @param {Array<Link>} links Tileset links.\n * @param {string} [mediaType] The preferred media type.\n * @param {Array<string>} [collections] Optional collections to append the URL with.\n * @return {string} The tile URL template.\n */\nexport function getMapTileUrlTemplate(links, mediaType, collections) {\n  let tileUrlTemplate;\n  let fallbackUrlTemplate;\n  for (let i = 0; i < links.length; ++i) {\n    const link = links[i];\n    if (link.rel === 'item') {\n      if (link.type === mediaType) {\n        tileUrlTemplate = link.href;\n        break;\n      }\n      if (knownMapMediaTypes[link.type]) {\n        fallbackUrlTemplate = link.href;\n      } else if (!fallbackUrlTemplate && link.type.startsWith('image/')) {\n        fallbackUrlTemplate = link.href;\n      }\n    }\n  }\n\n  if (!tileUrlTemplate) {\n    if (fallbackUrlTemplate) {\n      tileUrlTemplate = fallbackUrlTemplate;\n    } else {\n      throw new Error('Could not find \"item\" link');\n    }\n  }\n\n  if (collections) {\n    tileUrlTemplate = appendCollectionsQueryParam(tileUrlTemplate, collections);\n  }\n\n  return tileUrlTemplate;\n}\n\n/**\n * @param {Array<Link>} links Tileset links.\n * @param {string} [mediaType] The preferred media type.\n * @param {Array<string>} [supportedMediaTypes] The media types supported by the parser.\n * @param {Array<string>} [collections] Optional collections to append the URL with.\n * @return {string} The tile URL template.\n */\nexport function getVectorTileUrlTemplate(\n  links,\n  mediaType,\n  supportedMediaTypes,\n  collections,\n) {\n  let tileUrlTemplate;\n  let fallbackUrlTemplate;\n\n  /**\n   * Lookup of URL by media type.\n   * @type {Object<string, string>}\n   */\n  const hrefLookup = {};\n\n  for (let i = 0; i < links.length; ++i) {\n    const link = links[i];\n    hrefLookup[link.type] = link.href;\n    if (link.rel === 'item') {\n      if (link.type === mediaType) {\n        tileUrlTemplate = link.href;\n        break;\n      }\n      if (knownVectorMediaTypes[link.type]) {\n        fallbackUrlTemplate = link.href;\n      }\n    }\n  }\n\n  if (!tileUrlTemplate && supportedMediaTypes) {\n    for (let i = 0; i < supportedMediaTypes.length; ++i) {\n      const supportedMediaType = supportedMediaTypes[i];\n      if (hrefLookup[supportedMediaType]) {\n        tileUrlTemplate = hrefLookup[supportedMediaType];\n        break;\n      }\n    }\n  }\n\n  if (!tileUrlTemplate) {\n    if (fallbackUrlTemplate) {\n      tileUrlTemplate = fallbackUrlTemplate;\n    } else {\n      throw new Error('Could not find \"item\" link');\n    }\n  }\n\n  if (collections) {\n    tileUrlTemplate = appendCollectionsQueryParam(tileUrlTemplate, collections);\n  }\n\n  return tileUrlTemplate;\n}\n\n/**\n * @param {SourceInfo} sourceInfo The source info.\n * @param {TileMatrixSet} tileMatrixSet Tile matrix set.\n * @param {string} tileUrlTemplate Tile URL template.\n * @param {Array<TileMatrixSetLimit>} [tileMatrixSetLimits] Tile matrix set limits.\n * @return {TileSetInfo} Tile set info.\n */\nfunction parseTileMatrixSet(\n  sourceInfo,\n  tileMatrixSet,\n  tileUrlTemplate,\n  tileMatrixSetLimits,\n) {\n  let projection = sourceInfo.projection;\n  if (!projection) {\n    projection = getProjection(tileMatrixSet.crs);\n    if (!projection) {\n      throw new Error(`Unsupported CRS: ${tileMatrixSet.crs}`);\n    }\n  }\n  const orderedAxes = tileMatrixSet.orderedAxes;\n  const axisOrientation = orderedAxes\n    ? orderedAxes\n        .slice(0, 2)\n        .map((s) => s.replace(/E|X|Lon/i, 'e').replace(/N|Y|Lat/i, 'n'))\n        .join('')\n    : projection.getAxisOrientation();\n  const backwards = !axisOrientation.startsWith('en');\n\n  const matrices = tileMatrixSet.tileMatrices;\n\n  /**\n   * @type {Object<string, TileMatrix>}\n   */\n  const matrixLookup = {};\n  for (let i = 0; i < matrices.length; ++i) {\n    const matrix = matrices[i];\n    matrixLookup[matrix.id] = matrix;\n  }\n\n  /**\n   * @type {Object<string, TileMatrixSetLimit>}\n   */\n  const limitLookup = {};\n\n  /**\n   * @type {Array<string>}\n   */\n  const matrixIds = [];\n\n  if (tileMatrixSetLimits) {\n    for (let i = 0; i < tileMatrixSetLimits.length; ++i) {\n      const limit = tileMatrixSetLimits[i];\n      const id = limit.tileMatrix;\n      matrixIds.push(id);\n      limitLookup[id] = limit;\n    }\n  } else {\n    for (let i = 0; i < matrices.length; ++i) {\n      const id = matrices[i].id;\n      matrixIds.push(id);\n    }\n  }\n\n  const length = matrixIds.length;\n  const origins = new Array(length);\n  const resolutions = new Array(length);\n  const sizes = new Array(length);\n  const tileSizes = new Array(length);\n  const extent = [-Infinity, -Infinity, Infinity, Infinity];\n\n  for (let i = 0; i < length; ++i) {\n    const id = matrixIds[i];\n    const matrix = matrixLookup[id];\n    const origin = matrix.pointOfOrigin;\n    if (backwards) {\n      origins[i] = [origin[1], origin[0]];\n    } else {\n      origins[i] = origin;\n    }\n    resolutions[i] = matrix.cellSize;\n    sizes[i] = [matrix.matrixWidth, matrix.matrixHeight];\n    tileSizes[i] = [matrix.tileWidth, matrix.tileHeight];\n    const limit = limitLookup[id];\n    if (limit) {\n      const tileMapWidth = matrix.cellSize * matrix.tileWidth;\n      const minX = origins[i][0] + limit.minTileCol * tileMapWidth;\n      const maxX = origins[i][0] + (limit.maxTileCol + 1) * tileMapWidth;\n\n      const tileMapHeight = matrix.cellSize * matrix.tileHeight;\n      const upsideDown = matrix.cornerOfOrigin === 'bottomLeft';\n\n      let minY;\n      let maxY;\n      if (upsideDown) {\n        minY = origins[i][1] + limit.minTileRow * tileMapHeight;\n        maxY = origins[i][1] + (limit.maxTileRow + 1) * tileMapHeight;\n      } else {\n        minY = origins[i][1] - (limit.maxTileRow + 1) * tileMapHeight;\n        maxY = origins[i][1] - limit.minTileRow * tileMapHeight;\n      }\n\n      intersectExtents(extent, [minX, minY, maxX, maxY], extent);\n    }\n  }\n\n  const tileGrid = new TileGrid({\n    origins: origins,\n    resolutions: resolutions,\n    sizes: sizes,\n    tileSizes: tileSizes,\n    extent: tileMatrixSetLimits ? extent : undefined,\n  });\n\n  const context = sourceInfo.context;\n  const base = sourceInfo.url;\n\n  /** @type {import('../Tile.js').UrlFunction} */\n  function tileUrlFunction(tileCoord, pixelRatio, projection) {\n    if (!tileCoord) {\n      return undefined;\n    }\n\n    const id = matrixIds[tileCoord[0]];\n    const matrix = matrixLookup[id];\n    const upsideDown = matrix.cornerOfOrigin === 'bottomLeft';\n\n    const localContext = {\n      tileMatrix: id,\n      tileCol: tileCoord[1],\n      tileRow: upsideDown ? -tileCoord[2] - 1 : tileCoord[2],\n    };\n\n    if (tileMatrixSetLimits) {\n      const limit = limitLookup[matrix.id];\n      if (\n        localContext.tileCol < limit.minTileCol ||\n        localContext.tileCol > limit.maxTileCol ||\n        localContext.tileRow < limit.minTileRow ||\n        localContext.tileRow > limit.maxTileRow\n      ) {\n        return undefined;\n      }\n    }\n\n    Object.assign(localContext, context);\n\n    const url = tileUrlTemplate.replace(/\\{(\\w+?)\\}/g, function (m, p) {\n      return localContext[p];\n    });\n\n    return resolveUrl(base, url);\n  }\n\n  return {\n    grid: tileGrid,\n    urlTemplate: tileUrlTemplate,\n    urlFunction: tileUrlFunction,\n  };\n}\n\n/**\n * @param {SourceInfo} sourceInfo The source info.\n * @param {TileSet} tileSet Tile set.\n * @return {TileSetInfo|Promise<TileSetInfo>} Tile set info.\n */\nfunction parseTileSetMetadata(sourceInfo, tileSet) {\n  const tileMatrixSetLimits = tileSet.tileMatrixSetLimits;\n  /** @type {string} */\n  let tileUrlTemplate;\n\n  if (tileSet.dataType === 'map') {\n    tileUrlTemplate = getMapTileUrlTemplate(\n      tileSet.links,\n      sourceInfo.mediaType,\n      sourceInfo.collections,\n    );\n  } else if (tileSet.dataType === 'vector') {\n    tileUrlTemplate = getVectorTileUrlTemplate(\n      tileSet.links,\n      sourceInfo.mediaType,\n      sourceInfo.supportedMediaTypes,\n      sourceInfo.collections,\n    );\n  } else {\n    throw new Error('Expected tileset data type to be \"map\" or \"vector\"');\n  }\n\n  if (tileSet.tileMatrixSet) {\n    return parseTileMatrixSet(\n      sourceInfo,\n      tileSet.tileMatrixSet,\n      tileUrlTemplate,\n      tileMatrixSetLimits,\n    );\n  }\n\n  const tileMatrixSetLink = tileSet.links.find(\n    (link) =>\n      link.rel === 'http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme',\n  );\n  if (!tileMatrixSetLink) {\n    throw new Error(\n      'Expected http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme link or tileMatrixSet',\n    );\n  }\n  const tileMatrixSetDefinition = tileMatrixSetLink.href;\n\n  const url = resolveUrl(sourceInfo.url, tileMatrixSetDefinition);\n  return getJSON(url).then(function (tileMatrixSet) {\n    return parseTileMatrixSet(\n      sourceInfo,\n      tileMatrixSet,\n      tileUrlTemplate,\n      tileMatrixSetLimits,\n    );\n  });\n}\n\n/**\n * @param {SourceInfo} sourceInfo Source info.\n * @return {Promise<TileSetInfo>} Tile set info.\n */\nexport function getTileSetInfo(sourceInfo) {\n  return getJSON(sourceInfo.url).then(function (tileSet) {\n    return parseTileSetMetadata(sourceInfo, tileSet);\n  });\n}\n", "/**\n * @module ol/source/OGCMapTile\n */\nimport TileImage from './TileImage.js';\nimport {getTileSetInfo} from './ogcTileUtil.js';\nimport {error as logError} from '../console.js';\n\n/**\n * @typedef {Object} Options\n * @property {string} url URL to the OGC Map Tileset endpoint.\n * @property {Object} [context] A lookup of values to use in the tile URL template.  The `{tileMatrix}`\n * (zoom level), `{tileRow}`, and `{tileCol}` variables in the URL will always be provided by the source.\n * @property {string} [mediaType] The content type for the tiles (e.g. \"image/png\").  If not provided,\n * the source will try to find a link with rel=\"item\" that uses a supported image type.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. By default, the projection\n * will be derived from the `crs` of the `tileMatrixSet`.  You can override this by supplying\n * a projection to the constructor.\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(tile, src) {\n *   tile.getImage().src = src;\n * };\n * ```\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {Array<string>} [collections] A list of geospatial data sub-resources to include. If not provided, the entire dataset will\n * be included. This option is not applicable when requesting the tileset for a single collection.\n */\n\n/**\n * @classdesc\n * Layer source for map tiles from an [OGC API - Tiles](https://ogcapi.ogc.org/tiles/) service that provides \"map\" type tiles.\n * The service must conform to at least the core (http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/core)\n * and tileset (http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/tileset) conformance classes. For supporting the `collections`\n * option, the service must conform to the collections selection\n * (http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/collections-selection) conformance class.\n * @api\n */\nclass OGCMapTile extends TileImage {\n  /**\n   * @param {Options} options OGC map tile options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      interpolate: options.interpolate,\n      projection: options.projection,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      state: 'loading',\n      tileLoadFunction: options.tileLoadFunction,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      transition: options.transition,\n    });\n\n    const sourceInfo = {\n      url: options.url,\n      projection: this.getProjection(),\n      mediaType: options.mediaType,\n      context: options.context || null,\n      collections: options.collections,\n    };\n\n    getTileSetInfo(sourceInfo)\n      .then(this.handleTileSetInfo_.bind(this))\n      .catch(this.handleError_.bind(this));\n  }\n\n  /**\n   * @param {import(\"./ogcTileUtil.js\").TileSetInfo} tileSetInfo Tile set info.\n   * @private\n   */\n  handleTileSetInfo_(tileSetInfo) {\n    this.tileGrid = tileSetInfo.grid;\n    this.setTileUrlFunction(tileSetInfo.urlFunction, tileSetInfo.urlTemplate);\n    this.setState('ready');\n  }\n\n  /**\n   * @private\n   * @param {Error} error The error.\n   */\n  handleError_(error) {\n    logError(error);\n    this.setState('error');\n  }\n}\n\nexport default OGCMapTile;\n", "/**\n * @module ol/source/VectorTile\n */\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../VectorTile.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport TileState from '../TileState.js';\nimport UrlTile from './UrlTile.js';\nimport VectorRenderTile from '../VectorRenderTile.js';\nimport {DEFAULT_MAX_ZOOM} from '../tilegrid/common.js';\nimport {\n  buffer as bufferExtent,\n  getIntersection,\n  intersects,\n} from '../extent.js';\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\nimport {isEmpty} from '../obj.js';\nimport {loadFeaturesXhr} from '../featureloader.js';\nimport {toSize} from '../size.js';\n\n/**\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../render/Feature.js\").default]\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.\n * @property {import(\"../extent.js\").Extent} [extent] Extent.\n * @property {import(\"../format/Feature.js\").default<FeatureType>} [format] Feature format for tiles. Used and required by the default.\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\n * to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.\n * @property {import(\"./Source.js\").State} [state] Source state.\n * @property {typeof import(\"../VectorTile.js\").default} [tileClass] Class used to instantiate tiles.\n * Default is {@link module:ol/VectorTile~VectorTile}.\n * @property {number} [maxZoom=22] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=512] Optional tile size. Not used if `tileGrid` is provided.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction]\n * Optional function to load a tile given a URL. Could look like this for pbf tiles:\n * ```js\n * function(tile, url) {\n *   tile.setLoader(function(extent, resolution, projection) {\n *     fetch(url).then(function(response) {\n *       response.arrayBuffer().then(function(data) {\n *         const format = tile.getFormat() // ol/format/MVT configured as source format\n *         const features = format.readFeatures(data, {\n *           extent: extent,\n *           featureProjection: projection\n *         });\n *         tile.setFeatures(features);\n *       });\n *     });\n *   });\n * }\n * ```\n * If you do not need extent, resolution and projection to get the features for a tile (e.g.\n * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure\n * to call `setFeatures()` on the tile:\n * ```js\n * const format = new GeoJSON({featureProjection: map.getView().getProjection()});\n * async function tileLoadFunction(tile, url) {\n *   const response = await fetch(url);\n *   const data = await response.json();\n *   tile.setFeatures(format.readFeatures(data));\n * }\n * ```\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {number} [transition] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\n * render multiple worlds.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=1]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Class for layer sources providing vector data divided into a tile grid, to be\n * used with {@link module:ol/layer/VectorTile~VectorTileLayer}. Although this source receives tiles\n * with vector features from the server, it is not meant for feature editing.\n * Features are optimized for rendering, their geometries are clipped at or near\n * tile boundaries and simplified for a view resolution. See\n * {@link module:ol/source/Vector~VectorSource} for vector sources that are suitable for feature\n * editing.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../render/Feature.js\").default]\n */\nclass VectorTile extends UrlTile {\n  /**\n   * @param {!Options<FeatureType>} options Vector tile options.\n   */\n  constructor(options) {\n    const projection = options.projection || 'EPSG:3857';\n\n    const extent = options.extent || extentFromProjection(projection);\n\n    const tileGrid =\n      options.tileGrid ||\n      createXYZ({\n        extent: extent,\n        maxResolution: options.maxResolution,\n        maxZoom: options.maxZoom !== undefined ? options.maxZoom : 22,\n        minZoom: options.minZoom,\n        tileSize: options.tileSize || 512,\n      });\n\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      interpolate: true,\n      projection: projection,\n      state: options.state,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction\n        ? options.tileLoadFunction\n        : defaultLoadFunction,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX === undefined ? true : options.wrapX,\n      transition: options.transition,\n      zDirection: options.zDirection === undefined ? 1 : options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {import(\"../format/Feature.js\").default<FeatureType>|null}\n     */\n    this.format_ = options.format ? options.format : null;\n\n    /**\n     * @type {Object<string, Array<string>>}\n     * @private\n     */\n    this.tileKeysBySourceTileUrl_ = {};\n\n    /**\n     @type {Object<string, Tile<FeatureType>>}\n     */\n    this.sourceTiles_ = {};\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n\n    /**\n     * @protected\n     * @type {typeof import(\"../VectorTile.js\").default}\n     */\n    this.tileClass = options.tileClass ? options.tileClass : Tile;\n\n    /**\n     * @private\n     * @type {Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    this.tileGrids_ = {};\n  }\n\n  /**\n   * @return {boolean} The source can have overlapping geometries.\n   */\n  getOverlaps() {\n    return this.overlaps_;\n  }\n\n  /**\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection\").default} projection Projection.\n   * @param {VectorRenderTile} tile Vector render tile.\n   * @return {Array<import(\"../VectorTile\").default>} Tile keys.\n   */\n  getSourceTiles(pixelRatio, projection, tile) {\n    if (tile.getState() === TileState.IDLE) {\n      tile.setState(TileState.LOADING);\n      const urlTileCoord = tile.wrappedTileCoord;\n      const tileGrid = this.getTileGridForProjection(projection);\n      const extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      const z = urlTileCoord[0];\n      const resolution = tileGrid.getResolution(z);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      bufferExtent(extent, -resolution, extent);\n      const sourceTileGrid = this.tileGrid;\n      const sourceExtent = sourceTileGrid.getExtent();\n      if (sourceExtent) {\n        getIntersection(extent, sourceExtent, extent);\n      }\n      const sourceZ = sourceTileGrid.getZForResolution(\n        resolution,\n        this.zDirection,\n      );\n\n      sourceTileGrid.forEachTileCoord(extent, sourceZ, (sourceTileCoord) => {\n        const tileUrl = this.tileUrlFunction(\n          sourceTileCoord,\n          pixelRatio,\n          projection,\n        );\n        if (!this.sourceTiles_[tileUrl]) {\n          this.sourceTiles_[tileUrl] = new this.tileClass(\n            sourceTileCoord,\n            tileUrl ? TileState.IDLE : TileState.EMPTY,\n            tileUrl,\n            this.format_,\n            this.tileLoadFunction,\n          );\n        }\n        const sourceTile = this.sourceTiles_[tileUrl];\n        tile.sourceTiles.push(sourceTile);\n        if (!this.tileKeysBySourceTileUrl_[tileUrl]) {\n          this.tileKeysBySourceTileUrl_[tileUrl] = [];\n        }\n        this.tileKeysBySourceTileUrl_[tileUrl].push(tile.getKey());\n        const sourceTileState = sourceTile.getState();\n        if (sourceTileState < TileState.LOADED) {\n          const listenChange = (event) => {\n            this.handleTileChange(event);\n            const state = sourceTile.getState();\n            if (state === TileState.LOADED || state === TileState.ERROR) {\n              const sourceTileKey = sourceTile.getKey();\n              if (sourceTileKey in tile.errorTileKeys) {\n                if (sourceTile.getState() === TileState.LOADED) {\n                  delete tile.errorTileKeys[sourceTileKey];\n                }\n              } else {\n                tile.loadingSourceTiles--;\n              }\n              if (state === TileState.ERROR) {\n                tile.errorTileKeys[sourceTileKey] = true;\n              } else {\n                sourceTile.removeEventListener(EventType.CHANGE, listenChange);\n              }\n              if (tile.loadingSourceTiles === 0) {\n                tile.setState(\n                  isEmpty(tile.errorTileKeys)\n                    ? TileState.LOADED\n                    : TileState.ERROR,\n                );\n              }\n            }\n          };\n          sourceTile.addEventListener(EventType.CHANGE, listenChange);\n          tile.loadingSourceTiles++;\n        }\n        if (sourceTileState === TileState.IDLE) {\n          sourceTile.extent =\n            sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n          sourceTile.projection = projection;\n          sourceTile.resolution = sourceTileGrid.getResolution(\n            sourceTileCoord[0],\n          );\n          sourceTile.load();\n        }\n      });\n      if (!tile.loadingSourceTiles) {\n        tile.setState(\n          tile.sourceTiles.some(\n            (sourceTile) => sourceTile.getState() === TileState.ERROR,\n          )\n            ? TileState.ERROR\n            : TileState.LOADED,\n        );\n      }\n    }\n\n    return tile.sourceTiles;\n  }\n\n  /**\n   * @param {VectorRenderTile} tile Vector render tile.\n   */\n  removeSourceTiles(tile) {\n    const sourceTiles = tile.sourceTiles;\n    for (let i = 0, ii = sourceTiles.length; i < ii; ++i) {\n      const sourceTileUrl = sourceTiles[i].getTileUrl();\n      const tileKey = this.getKey();\n      if (!this.tileKeysBySourceTileUrl_[sourceTileUrl]) {\n        return;\n      }\n      const index = this.tileKeysBySourceTileUrl_[sourceTileUrl][tileKey];\n      if (index === -1) {\n        continue;\n      }\n      this.tileKeysBySourceTileUrl_[sourceTileUrl].splice(index, 1);\n      if (this.tileKeysBySourceTileUrl_[sourceTileUrl].length === 0) {\n        delete this.tileKeysBySourceTileUrl_[sourceTileUrl];\n        delete this.sourceTiles_[sourceTileUrl];\n      }\n    }\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!VectorRenderTile} Tile.\n   * @override\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const tileCoord = [z, x, y];\n    let urlTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      projection,\n    );\n    const sourceExtent = this.getTileGrid().getExtent();\n    const tileGrid = this.getTileGridForProjection(projection);\n    if (urlTileCoord && sourceExtent) {\n      const tileExtent = tileGrid.getTileCoordExtent(urlTileCoord);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      bufferExtent(tileExtent, -tileGrid.getResolution(z), tileExtent);\n      if (!intersects(sourceExtent, tileExtent)) {\n        urlTileCoord = null;\n      }\n    }\n    let empty = true;\n    if (urlTileCoord !== null) {\n      const sourceTileGrid = this.tileGrid;\n      const resolution = tileGrid.getResolution(z);\n      const sourceZ = sourceTileGrid.getZForResolution(resolution, 1);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      const extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      bufferExtent(extent, -resolution, extent);\n      sourceTileGrid.forEachTileCoord(extent, sourceZ, (sourceTileCoord) => {\n        empty =\n          empty &&\n          !this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n      });\n    }\n    const newTile = new VectorRenderTile(\n      tileCoord,\n      empty ? TileState.EMPTY : TileState.IDLE,\n      urlTileCoord,\n      this.getSourceTiles.bind(this, pixelRatio, projection),\n      this.removeSourceTiles.bind(this),\n    );\n    newTile.key = this.getKey();\n    return newTile;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   * @override\n   */\n  getTileGridForProjection(projection) {\n    const code = projection.getCode();\n    let tileGrid = this.tileGrids_[code];\n    if (!tileGrid) {\n      // A tile grid that matches the tile size of the source tile grid is more\n      // likely to have 1:1 relationships between source tiles and rendered tiles.\n      const sourceTileGrid = this.tileGrid;\n      const resolutions = sourceTileGrid.getResolutions().slice();\n      const origins = resolutions.map(function (resolution, z) {\n        return sourceTileGrid.getOrigin(z);\n      });\n      const tileSizes = resolutions.map(function (resolution, z) {\n        return sourceTileGrid.getTileSize(z);\n      });\n      const length = DEFAULT_MAX_ZOOM + 1;\n      for (let z = resolutions.length; z < length; ++z) {\n        resolutions.push(resolutions[z - 1] / 2);\n        origins.push(origins[z - 1]);\n        tileSizes.push(tileSizes[z - 1]);\n      }\n      tileGrid = new TileGrid({\n        extent: sourceTileGrid.getExtent(),\n        origins: origins,\n        resolutions: resolutions,\n        tileSizes: tileSizes,\n      });\n      this.tileGrids_[code] = tileGrid;\n    }\n    return tileGrid;\n  }\n\n  /**\n   * Get the tile pixel ratio for this source.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   * @override\n   */\n  getTilePixelRatio(pixelRatio) {\n    return pixelRatio;\n  }\n\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   * @override\n   */\n  getTilePixelSize(z, pixelRatio, projection) {\n    const tileGrid = this.getTileGridForProjection(projection);\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    return [\n      Math.round(tileSize[0] * pixelRatio),\n      Math.round(tileSize[1] * pixelRatio),\n    ];\n  }\n}\n\nexport default VectorTile;\n\n/**\n * Sets the loader for a tile.\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../render/Feature.js\").default]\n * @param {import(\"../VectorTile.js\").default<FeatureType>} tile Vector tile.\n * @param {string} url URL.\n */\nexport function defaultLoadFunction(tile, url) {\n  tile.setLoader(\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} resolution Resolution.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     */\n    function (extent, resolution, projection) {\n      loadFeaturesXhr(\n        url,\n        tile.getFormat(),\n        extent,\n        resolution,\n        projection,\n        tile.onLoad.bind(tile),\n        tile.onError.bind(tile),\n      );\n    },\n  );\n}\n", "/**\n * @module ol/source/OGCVectorTile\n */\n\nimport VectorTileSource from './VectorTile.js';\nimport {getTileSetInfo} from './ogcTileUtil.js';\nimport {error as logError} from '../console.js';\n\n/**\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../render/Feature.js\").default]\n * @typedef {Object} Options\n * @property {string} url URL to the OGC Vector Tileset endpoint.\n * @property {Object} [context] A lookup of values to use in the tile URL template.  The `{tileMatrix}`\n * (zoom level), `{tileRow}`, and `{tileCol}` variables in the URL will always be provided by the source.\n * @property {import(\"../format/Feature.js\").default<FeatureType>} [format] Feature format for tiles. Used and required by the default.\n * @property {string} [mediaType] The content type for the tiles (e.g. \"application/vnd.mapbox-vector-tile\").  If not provided,\n * the source will try to find a link with rel=\"item\" that uses a vector type supported by the configured format.\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\n * to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.\n * @property {typeof import(\"../VectorTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/VectorTile~VectorTile}.\n * @property {number} [transition] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\n * render multiple worlds.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=1]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n * @property {Array<string>} [collections] A list of geospatial data sub-resources to include. If not provided, the entire dataset will\n * be included. This option is not applicable when requesting the tileset for a single collection.\n */\n\n/**\n * @classdesc\n * Layer source for map tiles from an [OGC API - Tiles](https://ogcapi.ogc.org/tiles/) service that provides \"vector\" type tiles.\n * The service must conform to at least the core (http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/core)\n * and tileset (http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/tileset) conformance classes. For supporting the `collections`\n * option, the service must conform to the collections selection\n * (http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/collections-selection) conformance class.\n *\n * Vector tile sets may come in a variety of formats (e.g. GeoJSON, MVT).  The `format` option is used to determine\n * which of the advertised media types is used.  If you need to force the use of a particular media type, you can\n * provide the `mediaType` option.\n * @api\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../render/Feature.js\").default]\n * @extends {VectorTileSource<FeatureType>}\n */\nclass OGCVectorTile extends VectorTileSource {\n  /**\n   * @param {Options<FeatureType>} options OGC vector tile options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      format: options.format,\n      overlaps: options.overlaps,\n      projection: options.projection,\n      tileClass: options.tileClass,\n      transition: options.transition,\n      wrapX: options.wrapX,\n      zDirection: options.zDirection,\n      state: 'loading',\n    });\n\n    const sourceInfo = {\n      url: options.url,\n      projection: this.getProjection(),\n      mediaType: options.mediaType,\n      supportedMediaTypes: options.format.supportedMediaTypes,\n      context: options.context || null,\n      collections: options.collections,\n    };\n\n    getTileSetInfo(sourceInfo)\n      .then(this.handleTileSetInfo_.bind(this))\n      .catch(this.handleError_.bind(this));\n  }\n\n  /**\n   * @param {import(\"./ogcTileUtil.js\").TileSetInfo} tileSetInfo Tile set info.\n   * @private\n   */\n  handleTileSetInfo_(tileSetInfo) {\n    this.tileGrid = tileSetInfo.grid;\n    this.setTileUrlFunction(tileSetInfo.urlFunction, tileSetInfo.urlTemplate);\n    this.setState('ready');\n  }\n\n  /**\n   * @private\n   * @param {Error} error The error.\n   */\n  handleError_(error) {\n    logError(error);\n    this.setState('error');\n  }\n}\n\nexport default OGCVectorTile;\n", "/**\n * @module ol/source/Raster\n */\nimport Disposable from '../Disposable.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport ImageCanvas from '../ImageCanvas.js';\nimport ImageLayer from '../layer/Image.js';\nimport ImageSource from './Image.js';\nimport Source from './Source.js';\nimport TileLayer from '../layer/Tile.js';\nimport TileQueue from '../TileQueue.js';\nimport TileSource from './Tile.js';\nimport {createCanvasContext2D} from '../dom.js';\nimport {create as createTransform} from '../transform.js';\nimport {equals, getCenter, getHeight, getWidth} from '../extent.js';\nimport {getUid} from '../util.js';\n\n/**\n * @typedef {Object} MinionData\n * @property {Array<ArrayBuffer>} buffers Array of buffers.\n * @property {Object} meta Operation metadata.\n * @property {boolean} imageOps The operation is an image operation.\n * @property {number} width The width of the image.\n * @property {number} height The height of the image.\n */\n\n/* istanbul ignore next */\n/**\n * Create a function for running operations.  This function is serialized for\n * use in a worker.\n * @param {function(Array, Object):*} operation The operation.\n * @return {function(MinionData):ArrayBuffer} A function that takes an object with\n * buffers, meta, imageOps, width, and height properties and returns an array\n * buffer.\n */\nfunction createMinion(operation) {\n  return function (data) {\n    // bracket notation for minification support\n    const buffers = data['buffers'];\n    const meta = data['meta'];\n    const imageOps = data['imageOps'];\n    const width = data['width'];\n    const height = data['height'];\n\n    const numBuffers = buffers.length;\n    const numBytes = buffers[0].byteLength;\n\n    if (imageOps) {\n      const images = new Array(numBuffers);\n      for (let b = 0; b < numBuffers; ++b) {\n        images[b] = new ImageData(\n          new Uint8ClampedArray(buffers[b]),\n          width,\n          height,\n        );\n      }\n      const output = operation(images, meta).data;\n      return output.buffer;\n    }\n\n    const output = new Uint8ClampedArray(numBytes);\n    const arrays = new Array(numBuffers);\n    const pixels = new Array(numBuffers);\n    for (let b = 0; b < numBuffers; ++b) {\n      arrays[b] = new Uint8ClampedArray(buffers[b]);\n      pixels[b] = [0, 0, 0, 0];\n    }\n    for (let i = 0; i < numBytes; i += 4) {\n      for (let j = 0; j < numBuffers; ++j) {\n        const array = arrays[j];\n        pixels[j][0] = array[i];\n        pixels[j][1] = array[i + 1];\n        pixels[j][2] = array[i + 2];\n        pixels[j][3] = array[i + 3];\n      }\n      const pixel = operation(pixels, meta);\n      output[i] = pixel[0];\n      output[i + 1] = pixel[1];\n      output[i + 2] = pixel[2];\n      output[i + 3] = pixel[3];\n    }\n    return output.buffer;\n  };\n}\n\n/**\n * Create a worker for running operations.\n * @param {ProcessorOptions} config Processor options.\n * @param {function(MessageEvent): void} onMessage Called with a message event.\n * @return {Worker} The worker.\n */\nfunction createWorker(config, onMessage) {\n  const lib = Object.keys(config.lib || {}).map(function (name) {\n    return 'const ' + name + ' = ' + config.lib[name].toString() + ';';\n  });\n\n  const lines = lib.concat([\n    'const __minion__ = (' + createMinion.toString() + ')(',\n    config.operation.toString(),\n    ');',\n    'self.addEventListener(\"message\", function(event) {',\n    '  const buffer = __minion__(event.data);',\n    '  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);',\n    '});',\n  ]);\n\n  const worker = new Worker(\n    typeof Blob === 'undefined'\n      ? 'data:text/javascript;base64,' +\n        Buffer.from(lines.join('\\n'), 'binary').toString('base64')\n      : URL.createObjectURL(new Blob(lines, {type: 'text/javascript'})),\n  );\n  worker.addEventListener('message', onMessage);\n  return worker;\n}\n\n/**\n * @typedef {Object} FauxMessageEvent\n * @property {Object} data Message data.\n */\n\n/**\n * Create a faux worker for running operations.\n * @param {ProcessorOptions} config Configuration.\n * @param {function(FauxMessageEvent): void} onMessage Called with a message event.\n * @return {Object} The faux worker.\n */\nfunction createFauxWorker(config, onMessage) {\n  const minion = createMinion(config.operation);\n  let terminated = false;\n  return {\n    postMessage: function (data) {\n      setTimeout(function () {\n        if (terminated) {\n          return;\n        }\n        onMessage({data: {buffer: minion(data), meta: data['meta']}});\n      }, 0);\n    },\n    terminate: function () {\n      terminated = true;\n    },\n  };\n}\n\n/**\n * @typedef {function(Error, ImageData, (Object|Array<Object>)): void} JobCallback\n */\n\n/**\n * @typedef {Object} Job\n * @property {Object} meta Job metadata.\n * @property {Array<ImageData>} inputs Array of input data.\n * @property {JobCallback} callback Called when the job is complete.\n */\n\n/**\n * @typedef {Object} ProcessorOptions\n * @property {number} threads Number of workers to spawn.\n * @property {Operation} operation The operation.\n * @property {Object<string, Function>} [lib] Functions that will be made available to operations run in a worker.\n * @property {number} queue The number of queued jobs to allow.\n * @property {boolean} [imageOps=false] Pass all the image data to the operation instead of a single pixel.\n */\n\n/**\n * @classdesc\n * A processor runs pixel or image operations in workers.\n */\nexport class Processor extends Disposable {\n  /**\n   * @param {ProcessorOptions} config Configuration.\n   */\n  constructor(config) {\n    super();\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.imageOps_ = !!config.imageOps;\n    let threads;\n    if (config.threads === 0) {\n      threads = 0;\n    } else if (this.imageOps_) {\n      threads = 1;\n    } else {\n      threads = config.threads || 1;\n    }\n\n    /**\n     * @type {Array<Worker>}\n     */\n    const workers = new Array(threads);\n    if (threads) {\n      for (let i = 0; i < threads; ++i) {\n        workers[i] = createWorker(config, this.onWorkerMessage_.bind(this, i));\n      }\n    } else {\n      workers[0] = createFauxWorker(\n        config,\n        this.onWorkerMessage_.bind(this, 0),\n      );\n    }\n    /**\n     * @type {Array<Worker>}\n     * @private\n     */\n    this.workers_ = workers;\n\n    /**\n     * @type {Array<Job>}\n     * @private\n     */\n    this.queue_ = [];\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxQueueLength_ = config.queue || Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    this.running_ = 0;\n\n    /**\n     * @type {Object<number, any>}\n     * @private\n     */\n    this.dataLookup_ = {};\n\n    /**\n     * @type {Job|null}\n     * @private\n     */\n    this.job_ = null;\n  }\n\n  /**\n   * Run operation on input data.\n   * @param {Array<ImageData>} inputs Array of image data.\n   * @param {Object} meta A user data object.  This is passed to all operations\n   *     and must be serializable.\n   * @param {function(Error, ImageData, Object): void} callback Called when work\n   *     completes.  The first argument is any error.  The second is the ImageData\n   *     generated by operations.  The third is the user data object.\n   */\n  process(inputs, meta, callback) {\n    this.enqueue_({\n      inputs: inputs,\n      meta: meta,\n      callback: callback,\n    });\n    this.dispatch_();\n  }\n\n  /**\n   * Add a job to the queue.\n   * @param {Job} job The job.\n   */\n  enqueue_(job) {\n    this.queue_.push(job);\n    while (this.queue_.length > this.maxQueueLength_) {\n      this.queue_.shift().callback(null, null);\n    }\n  }\n\n  /**\n   * Dispatch a job.\n   */\n  dispatch_() {\n    if (this.running_ || this.queue_.length === 0) {\n      return;\n    }\n\n    const job = this.queue_.shift();\n    this.job_ = job;\n    const width = job.inputs[0].width;\n    const height = job.inputs[0].height;\n    const buffers = job.inputs.map(function (input) {\n      return input.data.buffer;\n    });\n    const threads = this.workers_.length;\n    this.running_ = threads;\n    if (threads === 1) {\n      this.workers_[0].postMessage(\n        {\n          buffers: buffers,\n          meta: job.meta,\n          imageOps: this.imageOps_,\n          width: width,\n          height: height,\n        },\n        buffers,\n      );\n      return;\n    }\n\n    const length = job.inputs[0].data.length;\n    const segmentLength = 4 * Math.ceil(length / 4 / threads);\n    for (let i = 0; i < threads; ++i) {\n      const offset = i * segmentLength;\n      const slices = [];\n      for (let j = 0, jj = buffers.length; j < jj; ++j) {\n        slices.push(buffers[j].slice(offset, offset + segmentLength));\n      }\n      this.workers_[i].postMessage(\n        {\n          buffers: slices,\n          meta: job.meta,\n          imageOps: this.imageOps_,\n          width: width,\n          height: height,\n        },\n        slices,\n      );\n    }\n  }\n\n  /**\n   * Handle messages from the worker.\n   * @param {number} index The worker index.\n   * @param {MessageEvent} event The message event.\n   */\n  onWorkerMessage_(index, event) {\n    if (this.disposed) {\n      return;\n    }\n    this.dataLookup_[index] = event.data;\n    --this.running_;\n    if (this.running_ === 0) {\n      this.resolveJob_();\n    }\n  }\n\n  /**\n   * Resolve a job.  If there are no more worker threads, the processor callback\n   * will be called.\n   */\n  resolveJob_() {\n    const job = this.job_;\n    const threads = this.workers_.length;\n    let data, meta;\n    if (threads === 1) {\n      data = new Uint8ClampedArray(this.dataLookup_[0]['buffer']);\n      meta = this.dataLookup_[0]['meta'];\n    } else {\n      const length = job.inputs[0].data.length;\n      data = new Uint8ClampedArray(length);\n      meta = new Array(threads);\n      const segmentLength = 4 * Math.ceil(length / 4 / threads);\n      for (let i = 0; i < threads; ++i) {\n        const buffer = this.dataLookup_[i]['buffer'];\n        const offset = i * segmentLength;\n        data.set(new Uint8ClampedArray(buffer), offset);\n        meta[i] = this.dataLookup_[i]['meta'];\n      }\n    }\n    this.job_ = null;\n    this.dataLookup_ = {};\n    job.callback(\n      null,\n      new ImageData(data, job.inputs[0].width, job.inputs[0].height),\n      meta,\n    );\n    this.dispatch_();\n  }\n\n  /**\n   * Terminate all workers associated with the processor.\n   * @override\n   */\n  disposeInternal() {\n    for (let i = 0; i < this.workers_.length; ++i) {\n      this.workers_[i].terminate();\n    }\n    this.workers_.length = 0;\n  }\n}\n\n/**\n * A function that takes an array of input data, performs some operation, and\n * returns an array of output data.\n * For `pixel` type operations, the function will be called with an array of\n * pixels, where each pixel is an array of four numbers (`[r, g, b, a]`) in the\n * range of 0 - 255. It should return a single pixel array.\n * For `'image'` type operations, functions will be called with an array of\n * [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData)\n * and should return a single\n * [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData).\n * The operations\n * are called with a second \"data\" argument, which can be used for storage.  The\n * data object is accessible from raster events, where it can be initialized in\n * \"beforeoperations\" and accessed again in \"afteroperations\".\n *\n * @typedef {function((Array<Array<number>>|Array<ImageData>), Object):\n *     (Array<number>|ImageData)} Operation\n */\n\n/**\n * @enum {string}\n */\nconst RasterEventType = {\n  /**\n   * Triggered before operations are run.  Listeners will receive an event object with\n   * a `data` property that can be used to make data available to operations.\n   * @event module:ol/source/Raster.RasterSourceEvent#beforeoperations\n   * @api\n   */\n  BEFOREOPERATIONS: 'beforeoperations',\n\n  /**\n   * Triggered after operations are run.  Listeners will receive an event object with\n   * a `data` property.  If more than one thread is used, `data` will be an array of\n   * objects.  If a single thread is used, `data` will be a single object.\n   * @event module:ol/source/Raster.RasterSourceEvent#afteroperations\n   * @api\n   */\n  AFTEROPERATIONS: 'afteroperations',\n};\n\n/**\n * @typedef {'pixel' | 'image'} RasterOperationType\n * Raster operation type. Supported values are `'pixel'` and `'image'`.\n */\n\n/**\n * @typedef {import(\"./Image.js\").ImageSourceEventTypes|'beforeoperations'|'afteroperations'} RasterSourceEventTypes\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Raster~RasterSource} instances are instances of this\n * type.\n */\nexport class RasterSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../Map.js\").FrameState} frameState The frame state.\n   * @param {Object|Array<Object>} data An object made available to operations.  For \"afteroperations\" evenets\n   * this will be an array of objects if more than one thread is used.\n   */\n  constructor(type, frameState, data) {\n    super(type);\n\n    /**\n     * The raster extent.\n     * @type {import(\"../extent.js\").Extent}\n     * @api\n     */\n    this.extent = frameState.extent;\n\n    /**\n     * The pixel resolution (map units per pixel).\n     * @type {number}\n     * @api\n     */\n    this.resolution = frameState.viewState.resolution / frameState.pixelRatio;\n\n    /**\n     * An object made available to all operations.  This can be used by operations\n     * as a storage object (e.g. for calculating statistics).\n     * @type {Object}\n     * @api\n     */\n    this.data = data;\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {Array<import(\"./Source.js\").default|import(\"../layer/Layer.js\").default>} sources Input\n * sources or layers.  For vector data, use an VectorImage layer.\n * @property {Operation} [operation] Raster operation.\n * The operation will be called with data from input sources\n * and the output will be assigned to the raster source.\n * @property {Object} [lib] Functions that will be made available to operations run in a worker.\n * @property {number} [threads] By default, operations will be run in a single worker thread.\n * To avoid using workers altogether, set `threads: 0`.  For pixel operations, operations can\n * be run in multiple worker threads.  Note that there is additional overhead in\n * transferring data to multiple workers, and that depending on the user's\n * system, it may not be possible to parallelize the work.\n * @property {RasterOperationType} [operationType='pixel'] Operation type.\n * Supported values are `'pixel'` and `'image'`.  By default,\n * `'pixel'` operations are assumed, and operations will be called with an\n * array of pixels from input sources.  If set to `'image'`, operations will\n * be called with an array of ImageData objects from input sources.\n * @property {Array<number>|null} [resolutions] Resolutions. If specified, raster operations will only\n * be run at the given resolutions.  By default, the resolutions of the first source with resolutions\n * specified will be used, if any. Set to `null` to use any view resolution instead.\n */\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Image.js\").ImageSourceEventTypes, import(\"./Image.js\").ImageSourceEvent, Return> &\n *   import(\"../Observable\").OnSignature<RasterSourceEventTypes, RasterSourceEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types\n *     |RasterSourceEventTypes, Return>} RasterSourceOnSignature\n */\n\n/**\n * @classdesc\n * A source that transforms data from any number of input sources using an\n * {@link module:ol/source/Raster~Operation} function to transform input pixel values into\n * output pixel values.\n *\n * @fires module:ol/source/Raster.RasterSourceEvent\n * @api\n */\nclass RasterSource extends ImageSource {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    super({\n      projection: null,\n    });\n\n    /***\n     * @type {RasterSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {RasterSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {RasterSourceOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {Processor}\n     */\n    this.processor_ = null;\n\n    /**\n     * @private\n     * @type {RasterOperationType}\n     */\n    this.operationType_ =\n      options.operationType !== undefined ? options.operationType : 'pixel';\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.threads_ = options.threads !== undefined ? options.threads : 1;\n\n    /**\n     * @private\n     * @type {Array<import(\"../layer/Layer.js\").default>}\n     */\n    this.layers_ = createLayers(options.sources);\n\n    const changed = this.changed.bind(this);\n    for (let i = 0, ii = this.layers_.length; i < ii; ++i) {\n      this.layers_[i].addEventListener(EventType.CHANGE, changed);\n    }\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.useResolutions_ = options.resolutions !== null;\n\n    /**\n     * @private\n     * @type {import(\"../TileQueue.js\").default}\n     */\n    this.tileQueue_ = new TileQueue(function () {\n      return 1;\n    }, this.processSources_.bind(this));\n\n    /**\n     * The most recently requested frame state.\n     * @type {import(\"../Map.js\").FrameState}\n     * @private\n     */\n    this.requestedFrameState_;\n\n    /**\n     * The most recently rendered image canvas.\n     * @type {import(\"../ImageCanvas.js\").default}\n     * @private\n     */\n    this.renderedImageCanvas_ = null;\n\n    /**\n     * The most recently rendered revision.\n     * @type {number}\n     * @private\n     */\n    this.renderedRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../Map.js\").FrameState}\n     */\n    this.frameState_ = {\n      animate: false,\n      coordinateToPixelTransform: createTransform(),\n      declutter: null,\n      extent: null,\n      index: 0,\n      layerIndex: 0,\n      layerStatesArray: getLayerStatesArray(this.layers_),\n      pixelRatio: 1,\n      pixelToCoordinateTransform: createTransform(),\n      postRenderFunctions: [],\n      size: [0, 0],\n      tileQueue: this.tileQueue_,\n      time: Date.now(),\n      usedTiles: {},\n      viewState: /** @type {import(\"../View.js\").State} */ ({\n        rotation: 0,\n      }),\n      viewHints: [],\n      wantedTiles: {},\n      mapId: getUid(this),\n      renderTargets: {},\n    };\n\n    this.setAttributions(function (frameState) {\n      /** @type {Array<string>} */\n      const attributions = [];\n      for (let i = 0, iMax = options.sources.length; i < iMax; ++i) {\n        const sourceOrLayer = options.sources[i];\n        const source =\n          sourceOrLayer instanceof Source\n            ? sourceOrLayer\n            : sourceOrLayer.getSource();\n        if (!source) {\n          continue;\n        }\n        const sourceAttributions = source.getAttributions()?.(frameState);\n        if (typeof sourceAttributions === 'string') {\n          attributions.push(sourceAttributions);\n        } else if (sourceAttributions !== undefined) {\n          attributions.push(...sourceAttributions);\n        }\n      }\n      return attributions;\n    });\n\n    if (options.operation !== undefined) {\n      this.setOperation(options.operation, options.lib);\n    }\n  }\n\n  /**\n   * Set the operation.\n   * @param {Operation} operation New operation.\n   * @param {Object} [lib] Functions that will be available to operations run\n   *     in a worker.\n   * @api\n   */\n  setOperation(operation, lib) {\n    if (this.processor_) {\n      this.processor_.dispose();\n    }\n\n    this.processor_ = new Processor({\n      operation: operation,\n      imageOps: this.operationType_ === 'image',\n      queue: 1,\n      lib: lib,\n      threads: this.threads_,\n    });\n    this.changed();\n  }\n\n  /**\n   * Update the stored frame state.\n   * @param {import(\"../extent.js\").Extent} extent The view extent (in map units).\n   * @param {number} resolution The view resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n   * @return {import(\"../Map.js\").FrameState} The updated frame state.\n   * @private\n   */\n  updateFrameState_(extent, resolution, projection) {\n    const frameState = /** @type {import(\"../Map.js\").FrameState} */ (\n      Object.assign({}, this.frameState_)\n    );\n\n    frameState.viewState = /** @type {import(\"../View.js\").State} */ (\n      Object.assign({}, frameState.viewState)\n    );\n\n    const center = getCenter(extent);\n\n    frameState.size[0] = Math.ceil(getWidth(extent) / resolution);\n    frameState.size[1] = Math.ceil(getHeight(extent) / resolution);\n    frameState.extent = [\n      center[0] - (frameState.size[0] * resolution) / 2,\n      center[1] - (frameState.size[1] * resolution) / 2,\n      center[0] + (frameState.size[0] * resolution) / 2,\n      center[1] + (frameState.size[1] * resolution) / 2,\n    ];\n    frameState.time = Date.now();\n\n    const viewState = frameState.viewState;\n    viewState.center = center;\n    viewState.projection = projection;\n    viewState.resolution = resolution;\n    return frameState;\n  }\n\n  /**\n   * Determine if all sources are ready.\n   * @return {boolean} All sources are ready.\n   * @private\n   */\n  allSourcesReady_() {\n    let ready = true;\n    let source;\n    for (let i = 0, ii = this.layers_.length; i < ii; ++i) {\n      source = this.layers_[i].getSource();\n      if (!source || source.getState() !== 'ready') {\n        ready = false;\n        break;\n      }\n    }\n    return ready;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../ImageCanvas.js\").default} Single image.\n   * @override\n   */\n  getImage(extent, resolution, pixelRatio, projection) {\n    if (!this.allSourcesReady_()) {\n      return null;\n    }\n\n    this.tileQueue_.loadMoreTiles(16, 16);\n\n    resolution = this.findNearestResolution(resolution);\n    const frameState = this.updateFrameState_(extent, resolution, projection);\n    this.requestedFrameState_ = frameState;\n\n    // check if we can't reuse the existing ol/ImageCanvas\n    if (this.renderedImageCanvas_) {\n      const renderedResolution = this.renderedImageCanvas_.getResolution();\n      const renderedExtent = this.renderedImageCanvas_.getExtent();\n      if (\n        resolution !== renderedResolution ||\n        !equals(frameState.extent, renderedExtent)\n      ) {\n        this.renderedImageCanvas_ = null;\n      }\n    }\n\n    if (\n      !this.renderedImageCanvas_ ||\n      this.getRevision() !== this.renderedRevision_\n    ) {\n      this.processSources_();\n    }\n\n    if (frameState.animate) {\n      requestAnimationFrame(this.changed.bind(this));\n    }\n\n    return this.renderedImageCanvas_;\n  }\n\n  /**\n   * Start processing source data.\n   * @private\n   */\n  processSources_() {\n    const frameState = this.requestedFrameState_;\n    const len = this.layers_.length;\n    const imageDatas = new Array(len);\n    for (let i = 0; i < len; ++i) {\n      frameState.layerIndex = i;\n      frameState.renderTargets = {};\n      const imageData = getImageData(this.layers_[i], frameState);\n      if (imageData) {\n        imageDatas[i] = imageData;\n      } else {\n        return;\n      }\n    }\n\n    const data = {};\n    this.dispatchEvent(\n      new RasterSourceEvent(RasterEventType.BEFOREOPERATIONS, frameState, data),\n    );\n    this.processor_.process(\n      imageDatas,\n      data,\n      this.onWorkerComplete_.bind(this, frameState),\n    );\n  }\n\n  /**\n   * Called when pixel processing is complete.\n   * @param {import(\"../Map.js\").FrameState} frameState The frame state.\n   * @param {Error} err Any error during processing.\n   * @param {ImageData} output The output image data.\n   * @param {Object|Array<Object>} data The user data (or an array if more than one thread).\n   * @private\n   */\n  onWorkerComplete_(frameState, err, output, data) {\n    if (err || !output) {\n      return;\n    }\n\n    // do nothing if extent or resolution changed\n    const extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    if (\n      resolution !== this.requestedFrameState_.viewState.resolution ||\n      !equals(extent, this.requestedFrameState_.extent)\n    ) {\n      return;\n    }\n\n    let context;\n    if (this.renderedImageCanvas_) {\n      context = this.renderedImageCanvas_.getImage().getContext('2d');\n    } else {\n      const width = Math.round(getWidth(extent) / resolution);\n      const height = Math.round(getHeight(extent) / resolution);\n      context = createCanvasContext2D(width, height);\n      this.renderedImageCanvas_ = new ImageCanvas(\n        extent,\n        resolution,\n        1,\n        context.canvas,\n      );\n    }\n    context.putImageData(output, 0, 0);\n\n    if (frameState.animate) {\n      requestAnimationFrame(this.changed.bind(this));\n    } else {\n      this.changed();\n    }\n    this.renderedRevision_ = this.getRevision();\n\n    this.dispatchEvent(\n      new RasterSourceEvent(RasterEventType.AFTEROPERATIONS, frameState, data),\n    );\n  }\n\n  /**\n   * @param {import(\"../proj/Projection\").default} [projection] Projection.\n   * @return {Array<number>|null} Resolutions.\n   * @override\n   */\n  getResolutions(projection) {\n    if (!this.useResolutions_) {\n      return null;\n    }\n    let resolutions = super.getResolutions();\n    if (!resolutions) {\n      for (let i = 0, ii = this.layers_.length; i < ii; ++i) {\n        const source = this.layers_[i].getSource();\n        resolutions = source.getResolutions(projection);\n        if (resolutions) {\n          break;\n        }\n      }\n    }\n    return resolutions;\n  }\n\n  /**\n   * @override\n   */\n  disposeInternal() {\n    if (this.processor_) {\n      this.processor_.dispose();\n    }\n    super.disposeInternal();\n  }\n}\n\n/**\n * Clean up and unregister the worker.\n * @function\n * @api\n */\nRasterSource.prototype.dispose;\n\n/**\n * A reusable canvas context.\n * @type {CanvasRenderingContext2D}\n * @private\n */\nlet sharedContext = null;\n\n/**\n * Get image data from a layer.\n * @param {import(\"../layer/Layer.js\").default} layer Layer to render.\n * @param {import(\"../Map.js\").FrameState} frameState The frame state.\n * @return {ImageData} The image data.\n */\nfunction getImageData(layer, frameState) {\n  const renderer = layer.getRenderer();\n  if (!renderer) {\n    throw new Error('Unsupported layer type: ' + layer);\n  }\n\n  if (!renderer.prepareFrame(frameState)) {\n    return null;\n  }\n  const width = frameState.size[0];\n  const height = frameState.size[1];\n  if (width === 0 || height === 0) {\n    return null;\n  }\n  const container = renderer.renderFrame(frameState, null);\n  let element;\n  if (container instanceof HTMLCanvasElement) {\n    element = container;\n  } else {\n    if (container) {\n      element = container.firstElementChild;\n    }\n    if (!(element instanceof HTMLCanvasElement)) {\n      throw new Error('Unsupported rendered element: ' + element);\n    }\n    if (element.width === width && element.height === height) {\n      const context = element.getContext('2d');\n      return context.getImageData(0, 0, width, height);\n    }\n  }\n\n  if (!sharedContext) {\n    sharedContext = createCanvasContext2D(width, height, undefined, {\n      willReadFrequently: true,\n    });\n  } else {\n    const canvas = sharedContext.canvas;\n    if (canvas.width !== width || canvas.height !== height) {\n      sharedContext = createCanvasContext2D(width, height, undefined, {\n        willReadFrequently: true,\n      });\n    } else {\n      sharedContext.clearRect(0, 0, width, height);\n    }\n  }\n  sharedContext.drawImage(element, 0, 0, width, height);\n  return sharedContext.getImageData(0, 0, width, height);\n}\n\n/**\n * Get a list of layer states from a list of layers.\n * @param {Array<import(\"../layer/Layer.js\").default>} layers Layers.\n * @return {Array<import(\"../layer/Layer.js\").State>} The layer states.\n */\nfunction getLayerStatesArray(layers) {\n  return layers.map(function (layer) {\n    return layer.getLayerState();\n  });\n}\n\n/**\n * Create layers for all sources.\n * @param {Array<import(\"./Source.js\").default|import(\"../layer/Layer.js\").default>} sources The sources.\n * @return {Array<import(\"../layer/Layer.js\").default>} Array of layers.\n */\nfunction createLayers(sources) {\n  const len = sources.length;\n  const layers = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    layers[i] = createLayer(sources[i]);\n  }\n  return layers;\n}\n\n/**\n * Create a layer for the provided source.\n * @param {import(\"./Source.js\").default|import(\"../layer/Layer.js\").default} layerOrSource The layer or source.\n * @return {import(\"../layer/Layer.js\").default} The layer.\n */\nfunction createLayer(layerOrSource) {\n  // @type {import(\"../layer/Layer.js\").default}\n  let layer;\n  if (layerOrSource instanceof Source) {\n    if (layerOrSource instanceof TileSource) {\n      layer = new TileLayer({source: layerOrSource});\n    } else if (layerOrSource instanceof ImageSource) {\n      layer = new ImageLayer({source: layerOrSource});\n    }\n  } else {\n    layer = layerOrSource;\n  }\n  return layer;\n}\n\nexport default RasterSource;\n", "/**\n * @module ol/source/StadiaMaps\n */\n\nimport XYZ from './XYZ.js';\nimport {ATTRIBUTION as OSM_ATTRIBUTION} from './OSM.js';\n\n/**\n * @const\n * @type string\n */\nconst STADIA_ATTRIBUTION =\n  '&copy; <a href=\"https://www.stadiamaps.com/\" target=\"_blank\">Stadia Maps</a>';\n\n/**\n * @const\n * @type string\n */\nconst OMT_ATTRIBUTION =\n  '&copy; <a href=\"https://openmaptiles.org/\" target=\"_blank\">OpenMapTiles</a>';\n\n/**\n * @const\n * @type string\n */\nconst STAMEN_ATTRIBUTION =\n  '&copy; <a href=\"https://stamen.com/\" target=\"_blank\">Stamen Design</a>';\n\n/**\n * @type {Object<string, {extension: string}>}\n */\nconst LayerConfig = {\n  'stamen_terrain': {\n    extension: 'png',\n  },\n  'stamen_terrain_background': {\n    extension: 'png',\n  },\n  'stamen_terrain_labels': {\n    extension: 'png',\n  },\n  'stamen_terrain_lines': {\n    extension: 'png',\n  },\n  'stamen_toner_background': {\n    extension: 'png',\n  },\n  'stamen_toner': {\n    extension: 'png',\n  },\n  'stamen_toner_labels': {\n    extension: 'png',\n  },\n  'stamen_toner_lines': {\n    extension: 'png',\n  },\n  'stamen_toner_lite': {\n    extension: 'png',\n  },\n  'stamen_watercolor': {\n    extension: 'jpg',\n  },\n  'alidade_smooth': {\n    extension: 'png',\n  },\n  'alidade_smooth_dark': {\n    extension: 'png',\n  },\n  'alidade_satellite': {\n    extension: 'png',\n  },\n  'outdoors': {\n    extension: 'png',\n  },\n  'osm_bright': {\n    extension: 'png',\n  },\n};\n\n/**\n * @type {Object<string, {minZoom: number, maxZoom: number, retina: boolean}>}\n */\nconst ProviderConfig = {\n  'stamen_terrain': {\n    minZoom: 0,\n    maxZoom: 18,\n    retina: true,\n  },\n  'stamen_toner': {\n    minZoom: 0,\n    maxZoom: 20,\n    retina: true,\n  },\n  'stamen_watercolor': {\n    minZoom: 1,\n    maxZoom: 18,\n    retina: false,\n  },\n};\n\n/**\n * @typedef {Object} Options\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {string} layer Layer name. Valid values: `alidade_smooth`, `alidade_smooth_dark`, `outdoors`, `stamen_terrain`, `stamen_terrain_background`, `stamen_terrain_labels`, `stamen_terrain_lines`, `stamen_toner_background`, `stamen_toner`, `stamen_toner_labels`, `stamen_toner_lines`, `stamen_toner_lite`, `stamen_watercolor`, and `osm_bright`.\n * @property {number} [minZoom] Minimum zoom.\n * @property {number} [maxZoom] Maximum zoom.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction]\n * Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n * @property {string} [apiKey] Stadia Maps API key. Not required for localhost or most public web deployments. See https://docs.stadiamaps.com/authentication/ for details.\n * @property {boolean} [retina] Use retina tiles (if available; not available for Stamen Watercolor).\n */\n\n/**\n * @classdesc\n * Layer source for the Stadia Maps tile server.\n * @api\n */\nclass StadiaMaps extends XYZ {\n  /**\n   * @param {Options} options StadiaMaps options.\n   */\n  constructor(options) {\n    const i = options.layer.indexOf('-');\n    const provider = i == -1 ? options.layer : options.layer.slice(0, i);\n    const providerConfig = ProviderConfig[provider] || {\n      'minZoom': 0,\n      'maxZoom': 20,\n      'retina': true,\n    };\n\n    const layerConfig = LayerConfig[options.layer];\n    const query = options.apiKey ? '?api_key=' + options.apiKey : '';\n    const retina = providerConfig.retina && options.retina ? '@2x' : '';\n\n    const url =\n      options.url !== undefined\n        ? options.url\n        : 'https://tiles.stadiamaps.com/tiles/' +\n          options.layer +\n          '/{z}/{x}/{y}' +\n          retina +\n          '.' +\n          layerConfig.extension +\n          query;\n\n    const attributions = [STADIA_ATTRIBUTION, OMT_ATTRIBUTION, OSM_ATTRIBUTION];\n\n    if (options.layer.startsWith('stamen_')) {\n      attributions.splice(1, 0, STAMEN_ATTRIBUTION);\n    }\n\n    super({\n      attributions: attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: 'anonymous',\n      interpolate: options.interpolate,\n      maxZoom:\n        options.maxZoom !== undefined\n          ? options.maxZoom\n          : providerConfig.maxZoom,\n      minZoom:\n        options.minZoom !== undefined\n          ? options.minZoom\n          : providerConfig.minZoom,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileLoadFunction: options.tileLoadFunction,\n      transition: options.transition,\n      url: url,\n      tilePixelRatio: retina ? 2 : 1,\n      wrapX: options.wrapX,\n      zDirection: options.zDirection,\n    });\n  }\n}\n\nexport default StadiaMaps;\n", "/**\n * @module ol/source/TileArcGISRest\n */\n\nimport TileImage from './TileImage.js';\nimport {createEmpty} from '../extent.js';\nimport {getRequestUrl} from './arcgisRest.js';\nimport {modulo} from '../math.js';\nimport {scale as scaleSize, toSize} from '../size.js';\nimport {hash as tileCoordHash} from '../tilecoord.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {Object<string,*>} [params] ArcGIS Rest parameters. This field is optional. Service defaults will be\n * used for any fields not specified. `FORMAT` is `PNG32` by default. `F` is `IMAGE` by\n * default. `TRANSPARENT` is `true` by default.  `BBOX`, `SIZE`, `BBOXSR`,\n * and `IMAGESR` will be set dynamically. Set `LAYERS` to\n * override the default service layer visibility. See\n * https://developers.arcgis.com/rest/services-reference/export-map.htm\n * for further reference.\n * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting\n * the image from the remote server.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid. Base this on the resolutions,\n * tilesize and extent supported by the server.\n * If this is not defined, a default grid will be used: if there is a projection\n * extent, the grid will be based on that; if not, a grid based on a global\n * extent with origin at 0,0 will be used.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * The projection code must contain a numeric end portion separated by :\n * or the entire code must form a valid ArcGIS SpatialReference definition.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL.\n * The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {string} [url] ArcGIS Rest service URL for a Map Service or Image Service. The\n * url should include /MapServer or /ImageServer.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number} [transition] Duration of the opacity transition for rendering.  To disable the opacity\n * transition, pass `transition: 0`.\n * @property {Array<string>} [urls] ArcGIS Rest service urls. Use this instead of `url` when the ArcGIS\n * Service supports multiple urls for export requests.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Layer source for tile data from ArcGIS Rest services. Map and Image\n * Services are supported.\n *\n * For cached ArcGIS services, better performance is available using the\n * {@link module:ol/source/XYZ~XYZ} data source.\n * @api\n */\nclass TileArcGISRest extends TileImage {\n  /**\n   * @param {Options} [options] Tile ArcGIS Rest options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      interpolate: options.interpolate,\n      projection: options.projection,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileGrid: options.tileGrid,\n      tileLoadFunction: options.tileLoadFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      transition: options.transition,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {!Object}\n     */\n    this.params_ = Object.assign({}, options.params);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.tmpExtent_ = createEmpty();\n\n    this.setKey(this.getKeyForParams_());\n  }\n\n  /**\n   * @private\n   * @return {string} The key for the current params.\n   */\n  getKeyForParams_() {\n    let i = 0;\n    const res = [];\n    for (const key in this.params_) {\n      res[i++] = key + '-' + this.params_[key];\n    }\n    return res.join('/');\n  }\n\n  /**\n   * Get the user-provided params, i.e. those passed to the constructor through\n   * the \"params\" option, and possibly updated using the updateParams method.\n   * @return {Object} Params.\n   * @api\n   */\n  getParams() {\n    return this.params_;\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../size.js\").Size} tileSize Tile size.\n   * @param {import(\"../extent.js\").Extent} tileExtent Tile extent.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {Object} params Params.\n   * @return {string|undefined} Request URL.\n   * @private\n   */\n  getRequestUrl_(\n    tileCoord,\n    tileSize,\n    tileExtent,\n    pixelRatio,\n    projection,\n    params,\n  ) {\n    const urls = this.urls;\n    if (!urls) {\n      return undefined;\n    }\n    let url;\n    if (urls.length == 1) {\n      url = urls[0];\n    } else {\n      const index = modulo(tileCoordHash(tileCoord), urls.length);\n      url = urls[index];\n    }\n\n    return getRequestUrl(\n      url,\n      tileExtent,\n      (\n        this.tileGrid || this.getTileGridForProjection(projection)\n      ).getResolution(tileCoord[0]),\n      pixelRatio,\n      projection,\n      params,\n    );\n  }\n\n  /**\n   * Get the tile pixel ratio for this source.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   * @override\n   */\n  getTilePixelRatio(pixelRatio) {\n    return this.hidpi_ ? pixelRatio : 1;\n  }\n\n  /**\n   * Update the user-provided params.\n   * @param {Object} params Params.\n   * @api\n   */\n  updateParams(params) {\n    Object.assign(this.params_, params);\n    this.setKey(this.getKeyForParams_());\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord The tile coordinate\n   * @param {number} pixelRatio The pixel ratio\n   * @param {import(\"../proj/Projection.js\").default} projection The projection\n   * @return {string|undefined} The tile URL\n   * @override\n   */\n  tileUrlFunction(tileCoord, pixelRatio, projection) {\n    let tileGrid = this.getTileGrid();\n    if (!tileGrid) {\n      tileGrid = this.getTileGridForProjection(projection);\n    }\n\n    if (tileGrid.getResolutions().length <= tileCoord[0]) {\n      return undefined;\n    }\n\n    if (pixelRatio != 1 && !this.hidpi_) {\n      pixelRatio = 1;\n    }\n\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);\n    let tileSize = toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);\n\n    if (pixelRatio != 1) {\n      tileSize = scaleSize(tileSize, pixelRatio, this.tmpSize);\n    }\n\n    // Apply default params and override with user specified values.\n    const baseParams = {\n      'F': 'image',\n      'FORMAT': 'PNG32',\n      'TRANSPARENT': true,\n    };\n    Object.assign(baseParams, this.params_);\n\n    return this.getRequestUrl_(\n      tileCoord,\n      tileSize,\n      tileExtent,\n      pixelRatio,\n      projection,\n      baseParams,\n    );\n  }\n}\n\nexport default TileArcGISRest;\n", "/**\n * @module ol/source/TileDebug\n */\n\nimport XYZ from './XYZ.js';\nimport {createCanvasContext2D} from '../dom.js';\nimport {toSize} from '../size.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Optional projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Set to `1` when debugging `VectorTile` sources with a default configuration.\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n * @property {string} [template='z:{z} x:{x} y:{y}'] Template for labeling the tiles.\n * Should include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n */\n\n/**\n * @classdesc\n * A pseudo tile source, which does not fetch tiles from a server, but renders\n * a grid outline for the tile grid/projection along with the coordinates for\n * each tile. See examples/canvas-tiles for an example.\n * @api\n */\nclass TileDebug extends XYZ {\n  /**\n   * @param {Options} [options] Debug tile options.\n   */\n  constructor(options) {\n    /**\n     * @type {Options}\n     */\n    options = options || {};\n\n    super({\n      projection: options.projection,\n      tileGrid: options.tileGrid,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      zDirection: options.zDirection,\n      url: options.template || 'z:{z} x:{x} y:{y}',\n      tileLoadFunction: (tile, text) => {\n        const z = tile.getTileCoord()[0];\n        const tileSize = toSize(this.tileGrid.getTileSize(z));\n        const context = createCanvasContext2D(tileSize[0], tileSize[1]);\n\n        context.strokeStyle = 'grey';\n        context.strokeRect(0.5, 0.5, tileSize[0] + 0.5, tileSize[1] + 0.5);\n\n        context.fillStyle = 'grey';\n        context.strokeStyle = 'white';\n        context.textAlign = 'center';\n        context.textBaseline = 'middle';\n        context.font = '24px sans-serif';\n        context.lineWidth = 4;\n        context.strokeText(text, tileSize[0] / 2, tileSize[1] / 2, tileSize[0]);\n        context.fillText(text, tileSize[0] / 2, tileSize[1] / 2, tileSize[0]);\n\n        /** @type {import(\"../ImageTile.js\").default} */ (tile).setImage(\n          context.canvas,\n        );\n      },\n    });\n  }\n}\n\nexport default TileDebug;\n", "/**\n * @module ol/source/TileJSON\n */\n// FIXME check order of async callbacks\n\n/**\n * See https://mapbox.com/developers/api/.\n */\n\nimport TileImage from './TileImage.js';\nimport {applyTransform, intersects} from '../extent.js';\nimport {createFromTemplates} from '../tileurlfunction.js';\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\nimport {get as getProjection, getTransformFromProjections} from '../proj.js';\nimport {jsonp as requestJSONP} from '../net.js';\n\n/**\n * @typedef {Object} Config\n * @property {string} [name] The name.\n * @property {string} [description] The description.\n * @property {string} [version] The version.\n * @property {string} [attribution] The attribution.\n * @property {string} [template] The template.\n * @property {string} [legend] The legend.\n * @property {string} [scheme] The scheme.\n * @property {Array<string>} tiles The tile URL templates.\n * @property {Array<string>} [grids] Optional grids.\n * @property {number} [minzoom] Minimum zoom level.\n * @property {number} [maxzoom] Maximum zoom level.\n * @property {Array<number>} [bounds] Optional bounds.\n * @property {Array<number>} [center] Optional center.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.\n * Useful when the server does not support CORS..\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {Config} [tileJSON] TileJSON configuration for this source.\n * If not provided, `url` must be configured.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The tile size used by the tile service.\n * Note: `tileSize` and other non-standard TileJSON properties are currently ignored.\n * @property {string} [url] URL to the TileJSON file. If not provided, `tileJSON` must be configured.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Layer source for tile data in TileJSON format.\n * @api\n */\nclass TileJSON extends TileImage {\n  /**\n   * @param {Options} options TileJSON options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      interpolate: options.interpolate,\n      projection: getProjection('EPSG:3857'),\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      state: 'loading',\n      tileLoadFunction: options.tileLoadFunction,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      transition: options.transition,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @type {Config}\n     * @private\n     */\n    this.tileJSON_ = null;\n\n    /**\n     * @type {number|import(\"../size.js\").Size}\n     * @private\n     */\n    this.tileSize_ = options.tileSize;\n\n    if (options.url) {\n      if (options.jsonp) {\n        requestJSONP(\n          options.url,\n          this.handleTileJSONResponse.bind(this),\n          this.handleTileJSONError.bind(this),\n        );\n      } else {\n        const client = new XMLHttpRequest();\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\n        client.addEventListener('error', this.onXHRError_.bind(this));\n        client.open('GET', options.url);\n        client.send();\n      }\n    } else if (options.tileJSON) {\n      this.handleTileJSONResponse(options.tileJSON);\n    } else {\n      throw new Error('Either `url` or `tileJSON` options must be provided');\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n  onXHRLoad_(event) {\n    const client = /** @type {XMLHttpRequest} */ (event.target);\n    // status will be 0 for file:// urls\n    if (!client.status || (client.status >= 200 && client.status < 300)) {\n      let response;\n      try {\n        response = /** @type {Config} */ (JSON.parse(client.responseText));\n      } catch (err) {\n        this.handleTileJSONError();\n        return;\n      }\n      this.handleTileJSONResponse(response);\n    } else {\n      this.handleTileJSONError();\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n  onXHRError_(event) {\n    this.handleTileJSONError();\n  }\n\n  /**\n   * @return {Config} The tilejson object.\n   * @api\n   */\n  getTileJSON() {\n    return this.tileJSON_;\n  }\n\n  /**\n   * @protected\n   * @param {Config} tileJSON Tile JSON.\n   */\n  handleTileJSONResponse(tileJSON) {\n    const epsg4326Projection = getProjection('EPSG:4326');\n\n    const sourceProjection = this.getProjection();\n    let extent;\n    if (tileJSON['bounds'] !== undefined) {\n      const transform = getTransformFromProjections(\n        epsg4326Projection,\n        sourceProjection,\n      );\n      extent = applyTransform(tileJSON['bounds'], transform);\n    }\n\n    const gridExtent = extentFromProjection(sourceProjection);\n    const minZoom = tileJSON['minzoom'] || 0;\n    const maxZoom = tileJSON['maxzoom'] || 22;\n    const tileGrid = createXYZ({\n      extent: gridExtent,\n      maxZoom: maxZoom,\n      minZoom: minZoom,\n      tileSize: this.tileSize_,\n    });\n    this.tileGrid = tileGrid;\n\n    this.tileUrlFunction = createFromTemplates(tileJSON['tiles'], tileGrid);\n\n    if (tileJSON['attribution'] && !this.getAttributions()) {\n      const attributionExtent = extent !== undefined ? extent : gridExtent;\n      this.setAttributions(function (frameState) {\n        if (intersects(attributionExtent, frameState.extent)) {\n          return [tileJSON['attribution']];\n        }\n        return null;\n      });\n    }\n    this.tileJSON_ = tileJSON;\n    this.setState('ready');\n  }\n\n  /**\n   * @protected\n   */\n  handleTileJSONError() {\n    this.setState('error');\n  }\n}\n\nexport default TileJSON;\n", "/**\n * @module ol/source/UTFGrid\n */\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileSource from './Tile.js';\nimport TileState from '../TileState.js';\nimport {applyTransform, intersects} from '../extent.js';\nimport {createFromTemplates, nullTileUrlFunction} from '../tileurlfunction.js';\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\nimport {get as getProjection, getTransformFromProjections} from '../proj.js';\nimport {listenOnce} from '../events.js';\nimport {jsonp as requestJSONP} from '../net.js';\n\n/**\n * @typedef {Object} UTFGridJSON\n * @property {Array<string>} grid The grid.\n * @property {Array<string>} keys The keys.\n * @property {Object<string, Object>} [data] Optional data.\n */\n\nexport class CustomTile extends Tile {\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {import(\"../extent.js\").Extent} extent Extent of the tile.\n   * @param {boolean} preemptive Load the tile when visible (before it's needed).\n   * @param {boolean} jsonp Load the tile as a script.\n   */\n  constructor(tileCoord, state, src, extent, preemptive, jsonp) {\n    super(tileCoord, state);\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = extent;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.preemptive_ = preemptive;\n\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n    this.grid_ = null;\n\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n    this.keys_ = null;\n\n    /**\n     * @private\n     * @type {Object<string, Object>|undefined}\n     */\n    this.data_ = null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.jsonp_ = jsonp;\n  }\n\n  /**\n   * Get the image element for this tile.\n   * @return {HTMLImageElement} Image.\n   */\n  getImage() {\n    return null;\n  }\n\n  /**\n   * Synchronously returns data at given coordinate (if available).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @return {*} The data.\n   */\n  getData(coordinate) {\n    if (!this.grid_ || !this.keys_) {\n      return null;\n    }\n    const xRelative =\n      (coordinate[0] - this.extent_[0]) / (this.extent_[2] - this.extent_[0]);\n    const yRelative =\n      (coordinate[1] - this.extent_[1]) / (this.extent_[3] - this.extent_[1]);\n\n    const row = this.grid_[Math.floor((1 - yRelative) * this.grid_.length)];\n\n    if (typeof row !== 'string') {\n      return null;\n    }\n\n    let code = row.charCodeAt(Math.floor(xRelative * row.length));\n    if (code >= 93) {\n      code--;\n    }\n    if (code >= 35) {\n      code--;\n    }\n    code -= 32;\n\n    let data = null;\n    if (code in this.keys_) {\n      const id = this.keys_[code];\n      if (this.data_ && id in this.data_) {\n        data = this.data_[id];\n      } else {\n        data = id;\n      }\n    }\n    return data;\n  }\n\n  /**\n   * Calls the callback (synchronously by default) with the available data\n   * for given coordinate (or `null` if not yet loaded).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {function(*): void} callback Callback.\n   * @param {boolean} [request] If `true` the callback is always async.\n   *                               The tile data is requested if not yet loaded.\n   */\n  forDataAtCoordinate(coordinate, callback, request) {\n    if (this.state == TileState.EMPTY && request === true) {\n      this.state = TileState.IDLE;\n      listenOnce(this, EventType.CHANGE, (e) => {\n        callback(this.getData(coordinate));\n      });\n      this.loadInternal_();\n    } else {\n      if (request === true) {\n        setTimeout(() => {\n          callback(this.getData(coordinate));\n        }, 0);\n      } else {\n        callback(this.getData(coordinate));\n      }\n    }\n  }\n\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   * @override\n   */\n  getKey() {\n    return this.src_;\n  }\n\n  /**\n   * @private\n   */\n  handleError_() {\n    this.state = TileState.ERROR;\n    this.changed();\n  }\n\n  /**\n   * @param {!UTFGridJSON} json UTFGrid data.\n   * @private\n   */\n  handleLoad_(json) {\n    this.grid_ = json['grid'];\n    this.keys_ = json['keys'];\n    this.data_ = json['data'];\n\n    this.state = TileState.LOADED;\n    this.changed();\n  }\n\n  /**\n   * @private\n   */\n  loadInternal_() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      if (this.jsonp_) {\n        requestJSONP(\n          this.src_,\n          this.handleLoad_.bind(this),\n          this.handleError_.bind(this),\n        );\n      } else {\n        const client = new XMLHttpRequest();\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\n        client.addEventListener('error', this.onXHRError_.bind(this));\n        client.open('GET', this.src_);\n        client.send();\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n  onXHRLoad_(event) {\n    const client = /** @type {XMLHttpRequest} */ (event.target);\n    // status will be 0 for file:// urls\n    if (!client.status || (client.status >= 200 && client.status < 300)) {\n      let response;\n      try {\n        response = /** @type {!UTFGridJSON} */ (\n          JSON.parse(client.responseText)\n        );\n      } catch (err) {\n        this.handleError_();\n        return;\n      }\n      this.handleLoad_(response);\n    } else {\n      this.handleError_();\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n  onXHRError_(event) {\n    this.handleError_();\n  }\n\n  /**\n   * @override\n   */\n  load() {\n    if (this.preemptive_) {\n      this.loadInternal_();\n    } else {\n      this.setState(TileState.EMPTY);\n    }\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [preemptive=true]\n * If `true` the UTFGrid source loads the tiles based on their \"visibility\".\n * This improves the speed of response, but increases traffic.\n * Note that if set to `false` (lazy loading), you need to pass `true` as\n * `request` to the `forDataAtCoordinateAndResolution` method otherwise no\n * data will ever be loaded.\n * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.\n * Useful when the server does not support CORS..\n * @property {import(\"./TileJSON.js\").Config} [tileJSON] TileJSON configuration for this source.\n * If not provided, `url` must be configured.\n * @property {string} [url] TileJSON endpoint that provides the configuration for this source.\n * Request will be made through JSONP. If not provided, `tileJSON` must be configured.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Layer source for UTFGrid interaction data loaded from TileJSON format.\n * @api\n */\nclass UTFGrid extends TileSource {\n  /**\n   * @param {Options} options Source options.\n   */\n  constructor(options) {\n    super({\n      projection: getProjection('EPSG:3857'),\n      state: 'loading',\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.preemptive_ =\n      options.preemptive !== undefined ? options.preemptive : true;\n\n    /**\n     * @private\n     * @type {!import(\"../Tile.js\").UrlFunction}\n     */\n    this.tileUrlFunction_ = nullTileUrlFunction;\n\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.template_ = undefined;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.jsonp_ = options.jsonp || false;\n\n    if (options.url) {\n      if (this.jsonp_) {\n        requestJSONP(\n          options.url,\n          this.handleTileJSONResponse.bind(this),\n          this.handleTileJSONError.bind(this),\n        );\n      } else {\n        const client = new XMLHttpRequest();\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\n        client.addEventListener('error', this.onXHRError_.bind(this));\n        client.open('GET', options.url);\n        client.send();\n      }\n    } else if (options.tileJSON) {\n      this.handleTileJSONResponse(options.tileJSON);\n    } else {\n      throw new Error('Either `url` or `tileJSON` options must be provided');\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n  onXHRLoad_(event) {\n    const client = /** @type {XMLHttpRequest} */ (event.target);\n    // status will be 0 for file:// urls\n    if (!client.status || (client.status >= 200 && client.status < 300)) {\n      let response;\n      try {\n        response = /** @type {import(\"./TileJSON.js\").Config} */ (\n          JSON.parse(client.responseText)\n        );\n      } catch (err) {\n        this.handleTileJSONError();\n        return;\n      }\n      this.handleTileJSONResponse(response);\n    } else {\n      this.handleTileJSONError();\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n  onXHRError_(event) {\n    this.handleTileJSONError();\n  }\n\n  /**\n   * Return the template from TileJSON.\n   * @return {string|undefined} The template from TileJSON.\n   * @api\n   */\n  getTemplate() {\n    return this.template_;\n  }\n\n  /**\n   * Calls the callback (synchronously by default) with the available data\n   * for given coordinate and resolution (or `null` if not yet loaded or\n   * in case of an error).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {function(*): void} callback Callback.\n   * @param {boolean} [request] If `true` the callback is always async.\n   *                               The tile data is requested if not yet loaded.\n   * @api\n   */\n  forDataAtCoordinateAndResolution(coordinate, resolution, callback, request) {\n    if (this.tileGrid) {\n      const z = this.tileGrid.getZForResolution(resolution, this.zDirection);\n      const tileCoord = this.tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = /** @type {!CustomTile} */ (\n        this.getTile(\n          tileCoord[0],\n          tileCoord[1],\n          tileCoord[2],\n          1,\n          this.getProjection(),\n        )\n      );\n      tile.forDataAtCoordinate(coordinate, callback, request);\n    } else {\n      if (request === true) {\n        setTimeout(function () {\n          callback(null);\n        }, 0);\n      } else {\n        callback(null);\n      }\n    }\n  }\n\n  /**\n   * @protected\n   */\n  handleTileJSONError() {\n    this.setState('error');\n  }\n\n  /**\n   * TODO: very similar to ol/source/TileJSON#handleTileJSONResponse\n   * @protected\n   * @param {import(\"./TileJSON.js\").Config} tileJSON Tile JSON.\n   */\n  handleTileJSONResponse(tileJSON) {\n    const epsg4326Projection = getProjection('EPSG:4326');\n\n    const sourceProjection = this.getProjection();\n    let extent;\n    if (tileJSON['bounds'] !== undefined) {\n      const transform = getTransformFromProjections(\n        epsg4326Projection,\n        sourceProjection,\n      );\n      extent = applyTransform(tileJSON['bounds'], transform);\n    }\n\n    const gridExtent = extentFromProjection(sourceProjection);\n    const minZoom = tileJSON['minzoom'] || 0;\n    const maxZoom = tileJSON['maxzoom'] || 22;\n    const tileGrid = createXYZ({\n      extent: gridExtent,\n      maxZoom: maxZoom,\n      minZoom: minZoom,\n    });\n    this.tileGrid = tileGrid;\n\n    this.template_ = tileJSON['template'];\n\n    const grids = tileJSON['grids'];\n    if (!grids) {\n      this.setState('error');\n      return;\n    }\n\n    this.tileUrlFunction_ = createFromTemplates(grids, tileGrid);\n\n    if (tileJSON['attribution']) {\n      const attributionExtent = extent !== undefined ? extent : gridExtent;\n      this.setAttributions(function (frameState) {\n        if (intersects(attributionExtent, frameState.extent)) {\n          return [tileJSON['attribution']];\n        }\n        return null;\n      });\n    }\n\n    this.setState('ready');\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!CustomTile} Tile.\n   * @override\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const tileCoord = [z, x, y];\n    const urlTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      projection,\n    );\n    const tileUrl = this.tileUrlFunction_(urlTileCoord, pixelRatio, projection);\n    const tile = new CustomTile(\n      tileCoord,\n      tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY,\n      tileUrl !== undefined ? tileUrl : '',\n      this.tileGrid.getTileCoordExtent(tileCoord),\n      this.preemptive_,\n      this.jsonp_,\n    );\n    return tile;\n  }\n}\n\nexport default UTFGrid;\n", "/**\n * @module ol/source/WMTS\n */\n\nimport TileImage from './TileImage.js';\nimport {appendParams, expandUrl} from '../uri.js';\nimport {containsExtent} from '../extent.js';\nimport {createFromCapabilitiesMatrixSet} from '../tilegrid/WMTS.js';\nimport {createFromTileUrlFunctions} from '../tileurlfunction.js';\nimport {equivalent, get as getProjection, transformExtent} from '../proj.js';\n\n/**\n * Request encoding. One of 'KVP', 'REST'.\n * @typedef {'KVP' | 'REST'} RequestEncoding\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {import(\"../tilegrid/WMTS.js\").default} tileGrid Tile grid.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {RequestEncoding} [requestEncoding='KVP'] Request encoding.\n * @property {string} layer Layer name as advertised in the WMTS capabilities.\n * @property {string} style Style name as advertised in the WMTS capabilities.\n * @property {typeof import(\"../ImageTile.js\").default} [tileClass]  Class used to instantiate image tiles. Default is {@link module:ol/ImageTile~ImageTile}.\n * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.\n * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px\n * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\n * should be set to `2`.\n * @property {string} [format='image/jpeg'] Image format. Only used when `requestEncoding` is `'KVP'`.\n * @property {string} [version='1.0.0'] WMTS version.\n * @property {string} matrixSet Matrix set.\n * @property {!Object} [dimensions] Additional \"dimensions\" for tile requests.\n * This is an object with properties named like the advertised WMTS dimensions.\n * @property {string} [url]  A URL for the service.\n * For the RESTful request encoding, this is a URL\n * template.  For KVP encoding, it is normal URL. A `{?-?}` template pattern,\n * for example `subdomain{a-f}.domain.com`, may be used instead of defining\n * each one separately in the `urls` option.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {Array<string>} [urls] An array of URLs.\n * Requests will be distributed among the URLs in this array.\n * @property {boolean} [wrapX=false] Whether to wrap the world horizontally.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Layer source for tile data from WMTS servers.\n * @api\n */\nclass WMTS extends TileImage {\n  /**\n   * @param {Options} options WMTS options.\n   */\n  constructor(options) {\n    // TODO: add support for TileMatrixLimits\n\n    const requestEncoding =\n      options.requestEncoding !== undefined ? options.requestEncoding : 'KVP';\n\n    // FIXME: should we create a default tileGrid?\n    // we could issue a getCapabilities xhr to retrieve missing configuration\n    const tileGrid = options.tileGrid;\n\n    let urls = options.urls;\n    if (urls === undefined && options.url !== undefined) {\n      urls = expandUrl(options.url);\n    }\n\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      interpolate: options.interpolate,\n      projection: options.projection,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileClass: options.tileClass,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction,\n      tilePixelRatio: options.tilePixelRatio,\n      urls: urls,\n      wrapX: options.wrapX !== undefined ? options.wrapX : false,\n      transition: options.transition,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.version_ = options.version !== undefined ? options.version : '1.0.0';\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.format_ = options.format !== undefined ? options.format : 'image/jpeg';\n\n    /**\n     * @private\n     * @type {!Object}\n     */\n    this.dimensions_ =\n      options.dimensions !== undefined ? options.dimensions : {};\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.layer_ = options.layer;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.matrixSet_ = options.matrixSet;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.style_ = options.style;\n\n    // FIXME: should we guess this requestEncoding from options.url(s)\n    //        structure? that would mean KVP only if a template is not provided.\n\n    /**\n     * @private\n     * @type {RequestEncoding}\n     */\n    this.requestEncoding_ = requestEncoding;\n\n    this.setKey(this.getKeyForDimensions_());\n\n    if (urls && urls.length > 0) {\n      this.tileUrlFunction = createFromTileUrlFunctions(\n        urls.map(this.createFromWMTSTemplate.bind(this)),\n      );\n    }\n  }\n\n  /**\n   * Set the URLs to use for requests.\n   * URLs may contain OGC conform URL Template Variables: {TileMatrix}, {TileRow}, {TileCol}.\n   * @param {Array<string>} urls URLs.\n   * @override\n   */\n  setUrls(urls) {\n    this.urls = urls;\n    const key = urls.join('\\n');\n    this.setTileUrlFunction(\n      createFromTileUrlFunctions(\n        urls.map(this.createFromWMTSTemplate.bind(this)),\n      ),\n      key,\n    );\n  }\n\n  /**\n   * Get the dimensions, i.e. those passed to the constructor through the\n   * \"dimensions\" option, and possibly updated using the updateDimensions\n   * method.\n   * @return {!Object} Dimensions.\n   * @api\n   */\n  getDimensions() {\n    return this.dimensions_;\n  }\n\n  /**\n   * Return the image format of the WMTS source.\n   * @return {string} Format.\n   * @api\n   */\n  getFormat() {\n    return this.format_;\n  }\n\n  /**\n   * Return the layer of the WMTS source.\n   * @return {string} Layer.\n   * @api\n   */\n  getLayer() {\n    return this.layer_;\n  }\n\n  /**\n   * Return the matrix set of the WMTS source.\n   * @return {string} MatrixSet.\n   * @api\n   */\n  getMatrixSet() {\n    return this.matrixSet_;\n  }\n\n  /**\n   * Return the request encoding, either \"KVP\" or \"REST\".\n   * @return {RequestEncoding} Request encoding.\n   * @api\n   */\n  getRequestEncoding() {\n    return this.requestEncoding_;\n  }\n\n  /**\n   * Return the style of the WMTS source.\n   * @return {string} Style.\n   * @api\n   */\n  getStyle() {\n    return this.style_;\n  }\n\n  /**\n   * Return the version of the WMTS source.\n   * @return {string} Version.\n   * @api\n   */\n  getVersion() {\n    return this.version_;\n  }\n\n  /**\n   * @private\n   * @return {string} The key for the current dimensions.\n   */\n  getKeyForDimensions_() {\n    const res = this.urls ? this.urls.slice(0) : [];\n    for (const key in this.dimensions_) {\n      res.push(key + '-' + this.dimensions_[key]);\n    }\n    return res.join('/');\n  }\n\n  /**\n   * Update the dimensions.\n   * @param {Object} dimensions Dimensions.\n   * @api\n   */\n  updateDimensions(dimensions) {\n    Object.assign(this.dimensions_, dimensions);\n    this.setKey(this.getKeyForDimensions_());\n  }\n\n  /**\n   * @param {string} template Template.\n   * @return {import(\"../Tile.js\").UrlFunction} Tile URL function.\n   */\n  createFromWMTSTemplate(template) {\n    const requestEncoding = this.requestEncoding_;\n\n    // context property names are lower case to allow for a case insensitive\n    // replacement as some services use different naming conventions\n    const context = {\n      'layer': this.layer_,\n      'style': this.style_,\n      'tilematrixset': this.matrixSet_,\n    };\n\n    if (requestEncoding == 'KVP') {\n      Object.assign(context, {\n        'Service': 'WMTS',\n        'Request': 'GetTile',\n        'Version': this.version_,\n        'Format': this.format_,\n      });\n    }\n\n    // TODO: we may want to create our own appendParams function so that params\n    // order conforms to wmts spec guidance, and so that we can avoid to escape\n    // special template params\n\n    template =\n      requestEncoding == 'KVP'\n        ? appendParams(template, context)\n        : template.replace(/\\{(\\w+?)\\}/g, function (m, p) {\n            return p.toLowerCase() in context ? context[p.toLowerCase()] : m;\n          });\n\n    const tileGrid = /** @type {import(\"../tilegrid/WMTS.js\").default} */ (\n      this.tileGrid\n    );\n    const dimensions = this.dimensions_;\n\n    return (\n      /**\n       * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n       * @param {number} pixelRatio Pixel ratio.\n       * @param {import(\"../proj/Projection.js\").default} projection Projection.\n       * @return {string|undefined} Tile URL.\n       */\n      function (tileCoord, pixelRatio, projection) {\n        if (!tileCoord) {\n          return undefined;\n        }\n        const localContext = {\n          'TileMatrix': tileGrid.getMatrixId(tileCoord[0]),\n          'TileCol': tileCoord[1],\n          'TileRow': tileCoord[2],\n        };\n        Object.assign(localContext, dimensions);\n        let url = template;\n        if (requestEncoding == 'KVP') {\n          url = appendParams(url, localContext);\n        } else {\n          url = url.replace(/\\{(\\w+?)\\}/g, function (m, p) {\n            return localContext[p];\n          });\n        }\n        return url;\n      }\n    );\n  }\n}\n\nexport default WMTS;\n\n/**\n * Generate source options from a capabilities object.\n * @param {Object} wmtsCap An object representing the capabilities document.\n * @param {!Object} config Configuration properties for the layer.  Defaults for\n *                  the layer will apply if not provided.\n *\n * Required config properties:\n *  - layer - {string} The layer identifier.\n *\n * Optional config properties:\n *  - matrixSet - {string} The matrix set identifier, required if there is\n *       more than one matrix set in the layer capabilities.\n *  - projection - {string} The desired CRS when no matrixSet is specified.\n *       eg: \"EPSG:3857\". If the desired projection is not available,\n *       an error is thrown.\n *  - requestEncoding - {string} url encoding format for the layer. Default is\n *       the first tile url format found in the GetCapabilities response.\n *  - style - {string} The name of the style\n *  - format - {string} Image format for the layer. Default is the first\n *       format returned in the GetCapabilities response.\n *  - crossOrigin - {string|null|undefined} Cross origin. Default is `undefined`.\n * @return {Options|null} WMTS source options object or `null` if the layer was not found.\n * @api\n */\nexport function optionsFromCapabilities(wmtsCap, config) {\n  const layers = wmtsCap['Contents']['Layer'];\n  const l = layers?.find(function (elt) {\n    return elt['Identifier'] == config['layer'];\n  });\n  if (!l) {\n    return null;\n  }\n  const tileMatrixSets = wmtsCap['Contents']['TileMatrixSet'];\n  let idx;\n  if (l['TileMatrixSetLink'].length > 1) {\n    if ('projection' in config) {\n      idx = l['TileMatrixSetLink'].findIndex(function (elt) {\n        const tileMatrixSet = tileMatrixSets.find(function (el) {\n          return el['Identifier'] == elt['TileMatrixSet'];\n        });\n        const supportedCRS = tileMatrixSet['SupportedCRS'];\n        const proj1 = getProjection(supportedCRS);\n        const proj2 = getProjection(config['projection']);\n        if (proj1 && proj2) {\n          return equivalent(proj1, proj2);\n        }\n        return supportedCRS == config['projection'];\n      });\n    } else {\n      idx = l['TileMatrixSetLink'].findIndex(function (elt) {\n        return elt['TileMatrixSet'] == config['matrixSet'];\n      });\n    }\n  } else {\n    idx = 0;\n  }\n  if (idx < 0) {\n    idx = 0;\n  }\n  const matrixSet =\n    /** @type {string} */\n    (l['TileMatrixSetLink'][idx]['TileMatrixSet']);\n  const matrixLimits =\n    /** @type {Array<Object>} */\n    (l['TileMatrixSetLink'][idx]['TileMatrixSetLimits']);\n\n  let format = /** @type {string} */ (l['Format'][0]);\n  if ('format' in config) {\n    format = config['format'];\n  }\n  idx = l['Style'].findIndex(function (elt) {\n    if ('style' in config) {\n      return elt['Title'] == config['style'];\n    }\n    return elt['isDefault'];\n  });\n  if (idx < 0) {\n    idx = 0;\n  }\n  const style = /** @type {string} */ (l['Style'][idx]['Identifier']);\n\n  const dimensions = {};\n  if ('Dimension' in l) {\n    l['Dimension'].forEach(function (elt, index, array) {\n      const key = elt['Identifier'];\n      let value = elt['Default'];\n      if (value === undefined) {\n        value = elt['Value'][0];\n      }\n      dimensions[key] = value;\n    });\n  }\n\n  const matrixSets = wmtsCap['Contents']['TileMatrixSet'];\n  const matrixSetObj = matrixSets.find(function (elt) {\n    return elt['Identifier'] == matrixSet;\n  });\n\n  let projection;\n  const code = matrixSetObj['SupportedCRS'];\n  if (code) {\n    projection = getProjection(code);\n  }\n  if ('projection' in config) {\n    const projConfig = getProjection(config['projection']);\n    if (projConfig) {\n      if (!projection || equivalent(projConfig, projection)) {\n        projection = projConfig;\n      }\n    }\n  }\n\n  let wrapX = false;\n  const switchXY = projection.getAxisOrientation().startsWith('ne');\n\n  let matrix = matrixSetObj.TileMatrix[0];\n\n  // create default matrixLimit\n  let selectedMatrixLimit = {\n    MinTileCol: 0,\n    MinTileRow: 0,\n    // subtract one to end up at tile top left\n    MaxTileCol: matrix.MatrixWidth - 1,\n    MaxTileRow: matrix.MatrixHeight - 1,\n  };\n\n  //in case of matrix limits, use matrix limits to calculate extent\n  if (matrixLimits) {\n    selectedMatrixLimit = matrixLimits[matrixLimits.length - 1];\n    const m = matrixSetObj.TileMatrix.find(\n      (tileMatrixValue) =>\n        tileMatrixValue.Identifier === selectedMatrixLimit.TileMatrix ||\n        matrixSetObj.Identifier + ':' + tileMatrixValue.Identifier ===\n          selectedMatrixLimit.TileMatrix,\n    );\n    if (m) {\n      matrix = m;\n    }\n  }\n\n  const resolution =\n    (matrix.ScaleDenominator * 0.00028) / projection.getMetersPerUnit(); // WMTS 1.0.0: standardized rendering pixel size\n  const origin = switchXY\n    ? [matrix.TopLeftCorner[1], matrix.TopLeftCorner[0]]\n    : matrix.TopLeftCorner;\n  const tileSpanX = matrix.TileWidth * resolution;\n  const tileSpanY = matrix.TileHeight * resolution;\n  let matrixSetExtent = matrixSetObj['BoundingBox'];\n  if (matrixSetExtent && switchXY) {\n    matrixSetExtent = [\n      matrixSetExtent[1],\n      matrixSetExtent[0],\n      matrixSetExtent[3],\n      matrixSetExtent[2],\n    ];\n  }\n  let extent = [\n    origin[0] + tileSpanX * selectedMatrixLimit.MinTileCol,\n    // add one to get proper bottom/right coordinate\n    origin[1] - tileSpanY * (1 + selectedMatrixLimit.MaxTileRow),\n    origin[0] + tileSpanX * (1 + selectedMatrixLimit.MaxTileCol),\n    origin[1] - tileSpanY * selectedMatrixLimit.MinTileRow,\n  ];\n\n  if (\n    matrixSetExtent !== undefined &&\n    !containsExtent(matrixSetExtent, extent)\n  ) {\n    const wgs84BoundingBox = l['WGS84BoundingBox'];\n    const wgs84ProjectionExtent = getProjection('EPSG:4326').getExtent();\n    extent = matrixSetExtent;\n    if (wgs84BoundingBox) {\n      wrapX =\n        wgs84BoundingBox[0] === wgs84ProjectionExtent[0] &&\n        wgs84BoundingBox[2] === wgs84ProjectionExtent[2];\n    } else {\n      const wgs84MatrixSetExtent = transformExtent(\n        matrixSetExtent,\n        matrixSetObj['SupportedCRS'],\n        'EPSG:4326',\n      );\n      // Ignore slight deviation from the correct x limits\n      wrapX =\n        wgs84MatrixSetExtent[0] - 1e-10 <= wgs84ProjectionExtent[0] &&\n        wgs84MatrixSetExtent[2] + 1e-10 >= wgs84ProjectionExtent[2];\n    }\n  }\n\n  const tileGrid = createFromCapabilitiesMatrixSet(\n    matrixSetObj,\n    extent,\n    matrixLimits,\n  );\n\n  /** @type {!Array<string>} */\n  const urls = [];\n  let requestEncoding = config['requestEncoding'];\n  requestEncoding = requestEncoding !== undefined ? requestEncoding : '';\n\n  if (\n    'OperationsMetadata' in wmtsCap &&\n    'GetTile' in wmtsCap['OperationsMetadata']\n  ) {\n    const gets = wmtsCap['OperationsMetadata']['GetTile']['DCP']['HTTP']['Get'];\n\n    for (let i = 0, ii = gets.length; i < ii; ++i) {\n      if (gets[i]['Constraint']) {\n        const constraint = gets[i]['Constraint'].find(function (element) {\n          return element['name'] == 'GetEncoding';\n        });\n        const encodings = constraint['AllowedValues']['Value'];\n\n        if (requestEncoding === '') {\n          // requestEncoding not provided, use the first encoding from the list\n          requestEncoding = encodings[0];\n        }\n        if (requestEncoding === 'KVP') {\n          if (encodings.includes('KVP')) {\n            urls.push(/** @type {string} */ (gets[i]['href']));\n          }\n        } else {\n          break;\n        }\n      } else if (gets[i]['href']) {\n        requestEncoding = 'KVP';\n        urls.push(/** @type {string} */ (gets[i]['href']));\n      }\n    }\n  }\n  if (urls.length === 0) {\n    requestEncoding = 'REST';\n    l['ResourceURL'].forEach(function (element) {\n      if (element['resourceType'] === 'tile') {\n        format = element['format'];\n        urls.push(/** @type {string} */ (element['template']));\n      }\n    });\n  }\n\n  return {\n    urls: urls,\n    layer: config['layer'],\n    matrixSet: matrixSet,\n    format: format,\n    projection: projection,\n    requestEncoding: requestEncoding,\n    tileGrid: tileGrid,\n    style: style,\n    dimensions: dimensions,\n    wrapX: wrapX,\n    crossOrigin: config['crossOrigin'],\n  };\n}\n", "/**\n * @module ol/source\n */\n\nimport LRUCache from './structs/LRUCache.js';\nimport {getIntersection} from './extent.js';\n\nexport {default as BingMaps} from './source/BingMaps.js';\nexport {default as CartoDB} from './source/CartoDB.js';\nexport {default as Cluster} from './source/Cluster.js';\nexport {default as DataTile} from './source/DataTile.js';\nexport {default as GeoTIFF} from './source/GeoTIFF.js';\nexport {default as Google} from './source/Google.js';\nexport {default as IIIF} from './source/IIIF.js';\nexport {default as Image} from './source/Image.js';\nexport {default as ImageArcGISRest} from './source/ImageArcGISRest.js';\nexport {default as ImageCanvas} from './source/ImageCanvas.js';\nexport {default as ImageMapGuide} from './source/ImageMapGuide.js';\nexport {default as ImageStatic} from './source/ImageStatic.js';\nexport {default as ImageTile} from './source/ImageTile.js';\nexport {default as ImageWMS} from './source/ImageWMS.js';\nexport {default as OGCMapTile} from './source/OGCMapTile.js';\nexport {default as OGCVectorTile} from './source/OGCVectorTile.js';\nexport {default as OSM} from './source/OSM.js';\nexport {default as Raster} from './source/Raster.js';\nexport {default as Source} from './source/Source.js';\nexport {default as StadiaMaps} from './source/StadiaMaps.js';\nexport {default as Tile} from './source/Tile.js';\nexport {default as TileArcGISRest} from './source/TileArcGISRest.js';\nexport {default as TileDebug} from './source/TileDebug.js';\nexport {default as TileImage} from './source/TileImage.js';\nexport {default as TileJSON} from './source/TileJSON.js';\nexport {default as TileWMS} from './source/TileWMS.js';\nexport {default as UrlTile} from './source/UrlTile.js';\nexport {default as UTFGrid} from './source/UTFGrid.js';\nexport {default as Vector} from './source/Vector.js';\nexport {default as VectorTile} from './source/VectorTile.js';\nexport {default as WMTS} from './source/WMTS.js';\nexport {default as XYZ} from './source/XYZ.js';\nexport {default as Zoomify} from './source/Zoomify.js';\nexport {createLoader as createWMSLoader} from './source/wms.js';\nexport {createLoader as createArcGISRestLoader} from './source/arcgisRest.js';\nexport {createLoader as createStaticLoader} from './source/static.js';\nexport {createLoader as createMapGuideLoader} from './source/mapguide.js';\n\n/**\n * Creates a sources function from a tile grid. This function can be used as value for the\n * `sources` property of the {@link module:ol/layer/Layer~Layer} subclasses that support it.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @param {function(import(\"./tilecoord.js\").TileCoord): import(\"./source/Source.js\").default} factory Source factory.\n * This function takes a {@link module:ol/tilecoord~TileCoord} as argument and is expected to return a\n * {@link module:ol/source/Source~Source}. **Note**: The returned sources should have a tile grid with\n * a limited set of resolutions, matching the resolution range of a single zoom level of the pyramid\n * `tileGrid` that `sourcesFromTileGrid` was called with.\n * @return {function(import(\"./extent.js\").Extent, number): Array<import(\"./source/Source.js\").default>} Sources function.\n * @api\n */\nexport function sourcesFromTileGrid(tileGrid, factory) {\n  const sourceCache = new LRUCache(32);\n  const tileGridExtent = tileGrid.getExtent();\n  return function (extent, resolution) {\n    sourceCache.expireCache();\n    if (tileGridExtent) {\n      extent = getIntersection(tileGridExtent, extent);\n    }\n    const z = tileGrid.getZForResolution(resolution);\n    const wantedSources = [];\n    tileGrid.forEachTileCoord(extent, z, (tileCoord) => {\n      const key = tileCoord.toString();\n      if (!sourceCache.containsKey(key)) {\n        const source = factory(tileCoord);\n        sourceCache.set(key, source);\n      }\n      wantedSources.push(sourceCache.get(key));\n    });\n    return wantedSources;\n  };\n}\n"],
  "mappings": "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",
  "names": ["maxZoom", "scale", "transform", "tileGrid", "extent", "geometry", "Tile_default", "z", "x", "y", "DataTile_default", "error", "DataTile_default", "url", "tileUrl", "maxZoom", "scale", "size", "createLoader", "image", "resolution", "Image_default", "createLoader", "Image_default", "ImageCanvas_default", "scale", "createLoader", "image", "Image_default", "createLoader", "createLoader", "image", "Image_default", "createLoader", "DataTile_default", "ImageTile_default", "Image_default", "client", "projection", "error", "tileUrl", "VectorTile_default", "VectorTile_default", "error", "output", "buffer", "Image_default", "Tile_default", "scale", "transform", "maxZoom", "CustomTile", "jsonp", "Tile_default", "transform", "maxZoom", "tileUrl"]
}
